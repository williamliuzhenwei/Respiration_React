{"ast":null,"code":"import _classCallCheck from \"/Users/liuzhenwei/Desktop/Respiration_React/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/liuzhenwei/Desktop/Respiration_React/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/liuzhenwei/Desktop/Respiration_React/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/liuzhenwei/Desktop/Respiration_React/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/**\n * @fileOverview random layout\n * @author shiwu.wyy@antfin.com\n */\nimport * as d3Force from \"d3-force\";\nimport forceInABox from \"./force-in-a-box\";\nimport { isArray, isFunction, isNumber, isObject } from \"../../util\";\nimport { Base } from \"../base\";\nimport { LAYOUT_MESSAGE } from \"../constants\";\n/**\n * 经典力导布局 force-directed\n */\n\nexport var ForceLayout = /*#__PURE__*/function (_Base) {\n  _inherits(ForceLayout, _Base);\n\n  var _super = _createSuper(ForceLayout);\n\n  function ForceLayout(options) {\n    var _this;\n\n    _classCallCheck(this, ForceLayout);\n\n    _this = _super.call(this);\n    /** 向心力作用点 */\n\n    _this.center = [0, 0];\n    /** 节点作用力 */\n\n    _this.nodeStrength = null;\n    /** 边的作用力, 默认为根据节点的入度出度自适应 */\n\n    _this.edgeStrength = null;\n    /** 是否防止节点相互覆盖 */\n\n    _this.preventOverlap = false;\n    /** 聚类节点作用力 */\n\n    _this.clusterNodeStrength = null;\n    /** 聚类边作用力 */\n\n    _this.clusterEdgeStrength = null;\n    /** 聚类边长度 */\n\n    _this.clusterEdgeDistance = null;\n    /** 聚类节点大小 / 直径，直径越大，越分散 */\n\n    _this.clusterNodeSize = null;\n    /** 用于 foci 的力 */\n\n    _this.clusterFociStrength = null;\n    /** 默认边长度 */\n\n    _this.linkDistance = 50;\n    /** 迭代阈值的衰减率 [0, 1]，0.028 对应最大迭代数为 300 */\n\n    _this.alphaDecay = 0.028;\n    /** 停止迭代的阈值 */\n\n    _this.alphaMin = 0.001;\n    /** 当前阈值 */\n\n    _this.alpha = 0.3;\n    /** 防止重叠的力强度 */\n\n    _this.collideStrength = 1;\n    /** 是否启用web worker。前提是在web worker里执行布局，否则无效\t*/\n\n    _this.workerEnabled = false;\n\n    _this.tick = function () {};\n    /** 布局完成回调 */\n\n\n    _this.onLayoutEnd = function () {};\n    /** 是否正在布局 */\n\n\n    _this.ticking = undefined;\n\n    if (options) {\n      _this.updateCfg(options);\n    }\n\n    return _this;\n  }\n\n  _createClass(ForceLayout, [{\n    key: \"getDefaultCfg\",\n    value: function getDefaultCfg() {\n      return {\n        center: [0, 0],\n        nodeStrength: null,\n        edgeStrength: null,\n        preventOverlap: false,\n        nodeSize: undefined,\n        nodeSpacing: undefined,\n        linkDistance: 50,\n        forceSimulation: null,\n        alphaDecay: 0.028,\n        alphaMin: 0.001,\n        alpha: 0.3,\n        collideStrength: 1,\n        clustering: false,\n        clusterNodeStrength: -1,\n        clusterEdgeStrength: 0.1,\n        clusterEdgeDistance: 100,\n        clusterFociStrength: 0.8,\n        clusterNodeSize: 10,\n        tick: function tick() {},\n        onLayoutEnd: function onLayoutEnd() {},\n        // 是否启用web worker。前提是在web worker里执行布局，否则无效\n        workerEnabled: false\n      };\n    }\n    /**\n     * 初始化\n     * @param {object} data 数据\n     */\n\n  }, {\n    key: \"init\",\n    value: function init(data) {\n      var self = this;\n      self.nodes = data.nodes || [];\n      var edges = data.edges || [];\n      self.edges = edges.map(function (edge) {\n        var res = {};\n        var expectKeys = [\"targetNode\", \"sourceNode\", \"startPoint\", \"endPoint\"];\n        Object.keys(edge).forEach(function (key) {\n          if (!(expectKeys.indexOf(key) > -1)) {\n            res[key] = edge[key];\n          }\n        });\n        return res;\n      });\n      self.ticking = false;\n    }\n    /**\n     * 执行布局\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute(reloadData) {\n      var self = this;\n      var nodes = self.nodes;\n      var edges = self.edges; // 如果正在布局，忽略布局请求\n\n      if (self.ticking) {\n        return;\n      }\n\n      var simulation = self.forceSimulation;\n      var alphaMin = self.alphaMin;\n      var alphaDecay = self.alphaDecay;\n      var alpha = self.alpha;\n\n      if (!simulation) {\n        try {\n          // 定义节点的力\n          var nodeForce = d3Force.forceManyBody();\n\n          if (self.nodeStrength) {\n            nodeForce.strength(self.nodeStrength);\n          }\n\n          simulation = d3Force.forceSimulation().nodes(nodes);\n\n          if (self.clustering) {\n            var clusterForce = forceInABox();\n            clusterForce.centerX(self.center[0]).centerY(self.center[1]).template(\"force\").strength(self.clusterFociStrength);\n\n            if (edges) {\n              clusterForce.links(edges);\n            }\n\n            if (nodes) {\n              clusterForce.nodes(nodes);\n            }\n\n            clusterForce.forceLinkDistance(self.clusterEdgeDistance).forceLinkStrength(self.clusterEdgeStrength).forceCharge(self.clusterNodeStrength).forceNodeSize(self.clusterNodeSize);\n            self.clusterForce = clusterForce;\n            simulation.force(\"group\", clusterForce);\n          }\n\n          simulation.force(\"center\", d3Force.forceCenter(self.center[0], self.center[1])).force(\"charge\", nodeForce).alpha(alpha).alphaDecay(alphaDecay).alphaMin(alphaMin);\n\n          if (self.preventOverlap) {\n            self.overlapProcess(simulation);\n          } // 如果有边，定义边的力\n\n\n          if (edges) {\n            // d3 的 forceLayout 会重新生成边的数据模型，为了避免污染源数据\n            var edgeForce = d3Force.forceLink().id(function (d) {\n              return d.id;\n            }).links(edges);\n\n            if (self.edgeStrength) {\n              edgeForce.strength(self.edgeStrength);\n            }\n\n            if (self.linkDistance) {\n              edgeForce.distance(self.linkDistance);\n            }\n\n            self.edgeForce = edgeForce;\n            simulation.force(\"link\", edgeForce);\n          }\n\n          if (self.workerEnabled && !isInWorker()) {\n            // 如果不是运行在web worker里，不用web worker布局\n            self.workerEnabled = false;\n            console.warn(\"workerEnabled option is only supported when running in web worker.\");\n          }\n\n          if (!self.workerEnabled) {\n            simulation.on(\"tick\", function () {\n              self.tick();\n            }).on(\"end\", function () {\n              self.ticking = false;\n              if (self.onLayoutEnd) self.onLayoutEnd();\n            });\n            self.ticking = true;\n          } else {\n            // worker is enabled\n            simulation.stop();\n            var totalTicks = getSimulationTicks(simulation);\n\n            for (var currentTick = 1; currentTick <= totalTicks; currentTick++) {\n              simulation.tick(); // currentTick starts from 1.\n\n              postMessage({\n                nodes: nodes,\n                currentTick: currentTick,\n                totalTicks: totalTicks,\n                type: LAYOUT_MESSAGE.TICK\n              }, undefined);\n            }\n\n            self.ticking = false;\n          }\n\n          self.forceSimulation = simulation;\n          self.ticking = true;\n        } catch (e) {\n          self.ticking = false;\n          console.warn(e);\n        }\n      } else {\n        if (reloadData) {\n          if (self.clustering && self.clusterForce) {\n            self.clusterForce.nodes(nodes);\n            self.clusterForce.links(edges);\n          }\n\n          simulation.nodes(nodes);\n          if (edges && self.edgeForce) self.edgeForce.links(edges);else if (edges && !self.edgeForce) {\n            // d3 的 forceLayout 会重新生成边的数据模型，为了避免污染源数据\n            var _edgeForce = d3Force.forceLink().id(function (d) {\n              return d.id;\n            }).links(edges);\n\n            if (self.edgeStrength) {\n              _edgeForce.strength(self.edgeStrength);\n            }\n\n            if (self.linkDistance) {\n              _edgeForce.distance(self.linkDistance);\n            }\n\n            self.edgeForce = _edgeForce;\n            simulation.force(\"link\", _edgeForce);\n          }\n        }\n\n        if (self.preventOverlap) {\n          self.overlapProcess(simulation);\n        }\n\n        simulation.alpha(alpha).restart();\n        this.ticking = true;\n      }\n    }\n    /**\n     * 防止重叠\n     * @param {object} simulation 力模拟模型\n     */\n\n  }, {\n    key: \"overlapProcess\",\n    value: function overlapProcess(simulation) {\n      var self = this;\n      var nodeSize = self.nodeSize;\n      var nodeSpacing = self.nodeSpacing;\n      var nodeSizeFunc;\n      var nodeSpacingFunc;\n      var collideStrength = self.collideStrength;\n\n      if (isNumber(nodeSpacing)) {\n        nodeSpacingFunc = function nodeSpacingFunc() {\n          return nodeSpacing;\n        };\n      } else if (isFunction(nodeSpacing)) {\n        nodeSpacingFunc = nodeSpacing;\n      } else {\n        nodeSpacingFunc = function nodeSpacingFunc() {\n          return 0;\n        };\n      }\n\n      if (!nodeSize) {\n        nodeSizeFunc = function nodeSizeFunc(d) {\n          if (d.size) {\n            if (isArray(d.size)) {\n              var res = d.size[0] > d.size[1] ? d.size[0] : d.size[1];\n              return res / 2 + nodeSpacingFunc(d);\n            }\n\n            if (isObject(d.size)) {\n              var _res = d.size.width > d.size.height ? d.size.width : d.size.height;\n\n              return _res / 2 + nodeSpacingFunc(d);\n            }\n\n            return d.size / 2 + nodeSpacingFunc(d);\n          }\n\n          return 10 + nodeSpacingFunc(d);\n        };\n      } else if (isFunction(nodeSize)) {\n        nodeSizeFunc = function nodeSizeFunc(d) {\n          var size = nodeSize(d);\n          return size + nodeSpacingFunc(d);\n        };\n      } else if (isArray(nodeSize)) {\n        var larger = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];\n        var radius = larger / 2;\n\n        nodeSizeFunc = function nodeSizeFunc(d) {\n          return radius + nodeSpacingFunc(d);\n        };\n      } else if (isNumber(nodeSize)) {\n        var _radius = nodeSize / 2;\n\n        nodeSizeFunc = function nodeSizeFunc(d) {\n          return _radius + nodeSpacingFunc(d);\n        };\n      } else {\n        nodeSizeFunc = function nodeSizeFunc() {\n          return 10;\n        };\n      } // forceCollide's parameter is a radius\n\n\n      simulation.force(\"collisionForce\", d3Force.forceCollide(nodeSizeFunc).strength(collideStrength));\n    }\n    /**\n     * 更新布局配置，但不执行布局\n     * @param {object} cfg 需要更新的配置项\n     */\n\n  }, {\n    key: \"updateCfg\",\n    value: function updateCfg(cfg) {\n      var self = this;\n\n      if (self.ticking) {\n        self.forceSimulation.stop();\n        self.ticking = false;\n      }\n\n      self.forceSimulation = null;\n      Object.assign(self, cfg);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var self = this;\n\n      if (self.ticking) {\n        self.forceSimulation.stop();\n        self.ticking = false;\n      }\n\n      self.nodes = null;\n      self.edges = null;\n      self.destroyed = true;\n    }\n  }]);\n\n  return ForceLayout;\n}(Base); // Return total ticks of d3-force simulation\n\nfunction getSimulationTicks(simulation) {\n  var alphaMin = simulation.alphaMin();\n  var alphaTarget = simulation.alphaTarget();\n  var alpha = simulation.alpha();\n  var totalTicksFloat = Math.log((alphaMin - alphaTarget) / (alpha - alphaTarget)) / Math.log(1 - simulation.alphaDecay());\n  var totalTicks = Math.ceil(totalTicksFloat);\n  return totalTicks;\n} // 判断是否运行在web worker里\n\n\nfunction isInWorker() {\n  // eslint-disable-next-line no-undef\n  return typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope;\n}","map":{"version":3,"sources":["../../../src/layout/force/force.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @fileOverview random layout\n * @author shiwu.wyy@antfin.com\n */\nimport * as d3Force from \"d3-force\";\nimport forceInABox from \"./force-in-a-box\";\nimport { isArray, isFunction, isNumber, isObject } from \"../../util\";\nimport { Base } from \"../base\";\nimport { LAYOUT_MESSAGE } from \"../constants\";\n/**\n * 经典力导布局 force-directed\n */\nexport class ForceLayout extends Base {\n    constructor(options) {\n        super();\n        /** 向心力作用点 */\n        this.center = [0, 0];\n        /** 节点作用力 */\n        this.nodeStrength = null;\n        /** 边的作用力, 默认为根据节点的入度出度自适应 */\n        this.edgeStrength = null;\n        /** 是否防止节点相互覆盖 */\n        this.preventOverlap = false;\n        /** 聚类节点作用力 */\n        this.clusterNodeStrength = null;\n        /** 聚类边作用力 */\n        this.clusterEdgeStrength = null;\n        /** 聚类边长度 */\n        this.clusterEdgeDistance = null;\n        /** 聚类节点大小 / 直径，直径越大，越分散 */\n        this.clusterNodeSize = null;\n        /** 用于 foci 的力 */\n        this.clusterFociStrength = null;\n        /** 默认边长度 */\n        this.linkDistance = 50;\n        /** 迭代阈值的衰减率 [0, 1]，0.028 对应最大迭代数为 300 */\n        this.alphaDecay = 0.028;\n        /** 停止迭代的阈值 */\n        this.alphaMin = 0.001;\n        /** 当前阈值 */\n        this.alpha = 0.3;\n        /** 防止重叠的力强度 */\n        this.collideStrength = 1;\n        /** 是否启用web worker。前提是在web worker里执行布局，否则无效\t*/\n        this.workerEnabled = false;\n        this.tick = () => { };\n        /** 布局完成回调 */\n        this.onLayoutEnd = () => { };\n        /** 是否正在布局 */\n        this.ticking = undefined;\n        if (options) {\n            this.updateCfg(options);\n        }\n    }\n    getDefaultCfg() {\n        return {\n            center: [0, 0],\n            nodeStrength: null,\n            edgeStrength: null,\n            preventOverlap: false,\n            nodeSize: undefined,\n            nodeSpacing: undefined,\n            linkDistance: 50,\n            forceSimulation: null,\n            alphaDecay: 0.028,\n            alphaMin: 0.001,\n            alpha: 0.3,\n            collideStrength: 1,\n            clustering: false,\n            clusterNodeStrength: -1,\n            clusterEdgeStrength: 0.1,\n            clusterEdgeDistance: 100,\n            clusterFociStrength: 0.8,\n            clusterNodeSize: 10,\n            tick() { },\n            onLayoutEnd() { },\n            // 是否启用web worker。前提是在web worker里执行布局，否则无效\n            workerEnabled: false\n        };\n    }\n    /**\n     * 初始化\n     * @param {object} data 数据\n     */\n    init(data) {\n        const self = this;\n        self.nodes = data.nodes || [];\n        const edges = data.edges || [];\n        self.edges = edges.map((edge) => {\n            const res = {};\n            const expectKeys = [\"targetNode\", \"sourceNode\", \"startPoint\", \"endPoint\"];\n            Object.keys(edge).forEach((key) => {\n                if (!(expectKeys.indexOf(key) > -1)) {\n                    res[key] = edge[key];\n                }\n            });\n            return res;\n        });\n        self.ticking = false;\n    }\n    /**\n     * 执行布局\n     */\n    execute(reloadData) {\n        const self = this;\n        const nodes = self.nodes;\n        const edges = self.edges;\n        // 如果正在布局，忽略布局请求\n        if (self.ticking) {\n            return;\n        }\n        let simulation = self.forceSimulation;\n        const alphaMin = self.alphaMin;\n        const alphaDecay = self.alphaDecay;\n        const alpha = self.alpha;\n        if (!simulation) {\n            try {\n                // 定义节点的力\n                const nodeForce = d3Force.forceManyBody();\n                if (self.nodeStrength) {\n                    nodeForce.strength(self.nodeStrength);\n                }\n                simulation = d3Force.forceSimulation().nodes(nodes);\n                if (self.clustering) {\n                    const clusterForce = forceInABox();\n                    clusterForce\n                        .centerX(self.center[0])\n                        .centerY(self.center[1])\n                        .template(\"force\")\n                        .strength(self.clusterFociStrength);\n                    if (edges) {\n                        clusterForce.links(edges);\n                    }\n                    if (nodes) {\n                        clusterForce.nodes(nodes);\n                    }\n                    clusterForce\n                        .forceLinkDistance(self.clusterEdgeDistance)\n                        .forceLinkStrength(self.clusterEdgeStrength)\n                        .forceCharge(self.clusterNodeStrength)\n                        .forceNodeSize(self.clusterNodeSize);\n                    self.clusterForce = clusterForce;\n                    simulation.force(\"group\", clusterForce);\n                }\n                simulation\n                    .force(\"center\", d3Force.forceCenter(self.center[0], self.center[1]))\n                    .force(\"charge\", nodeForce)\n                    .alpha(alpha)\n                    .alphaDecay(alphaDecay)\n                    .alphaMin(alphaMin);\n                if (self.preventOverlap) {\n                    self.overlapProcess(simulation);\n                }\n                // 如果有边，定义边的力\n                if (edges) {\n                    // d3 的 forceLayout 会重新生成边的数据模型，为了避免污染源数据\n                    const edgeForce = d3Force\n                        .forceLink()\n                        .id((d) => d.id)\n                        .links(edges);\n                    if (self.edgeStrength) {\n                        edgeForce.strength(self.edgeStrength);\n                    }\n                    if (self.linkDistance) {\n                        edgeForce.distance(self.linkDistance);\n                    }\n                    self.edgeForce = edgeForce;\n                    simulation.force(\"link\", edgeForce);\n                }\n                if (self.workerEnabled && !isInWorker()) {\n                    // 如果不是运行在web worker里，不用web worker布局\n                    self.workerEnabled = false;\n                    console.warn(\"workerEnabled option is only supported when running in web worker.\");\n                }\n                if (!self.workerEnabled) {\n                    simulation\n                        .on(\"tick\", () => {\n                        self.tick();\n                    })\n                        .on(\"end\", () => {\n                        self.ticking = false;\n                        if (self.onLayoutEnd)\n                            self.onLayoutEnd();\n                    });\n                    self.ticking = true;\n                }\n                else {\n                    // worker is enabled\n                    simulation.stop();\n                    const totalTicks = getSimulationTicks(simulation);\n                    for (let currentTick = 1; currentTick <= totalTicks; currentTick++) {\n                        simulation.tick();\n                        // currentTick starts from 1.\n                        postMessage({\n                            nodes,\n                            currentTick,\n                            totalTicks,\n                            type: LAYOUT_MESSAGE.TICK\n                        }, undefined);\n                    }\n                    self.ticking = false;\n                }\n                self.forceSimulation = simulation;\n                self.ticking = true;\n            }\n            catch (e) {\n                self.ticking = false;\n                console.warn(e);\n            }\n        }\n        else {\n            if (reloadData) {\n                if (self.clustering && self.clusterForce) {\n                    self.clusterForce.nodes(nodes);\n                    self.clusterForce.links(edges);\n                }\n                simulation.nodes(nodes);\n                if (edges && self.edgeForce)\n                    self.edgeForce.links(edges);\n                else if (edges && !self.edgeForce) {\n                    // d3 的 forceLayout 会重新生成边的数据模型，为了避免污染源数据\n                    const edgeForce = d3Force\n                        .forceLink()\n                        .id((d) => d.id)\n                        .links(edges);\n                    if (self.edgeStrength) {\n                        edgeForce.strength(self.edgeStrength);\n                    }\n                    if (self.linkDistance) {\n                        edgeForce.distance(self.linkDistance);\n                    }\n                    self.edgeForce = edgeForce;\n                    simulation.force(\"link\", edgeForce);\n                }\n            }\n            if (self.preventOverlap) {\n                self.overlapProcess(simulation);\n            }\n            simulation.alpha(alpha).restart();\n            this.ticking = true;\n        }\n    }\n    /**\n     * 防止重叠\n     * @param {object} simulation 力模拟模型\n     */\n    overlapProcess(simulation) {\n        const self = this;\n        const nodeSize = self.nodeSize;\n        const nodeSpacing = self.nodeSpacing;\n        let nodeSizeFunc;\n        let nodeSpacingFunc;\n        const collideStrength = self.collideStrength;\n        if (isNumber(nodeSpacing)) {\n            nodeSpacingFunc = () => nodeSpacing;\n        }\n        else if (isFunction(nodeSpacing)) {\n            nodeSpacingFunc = nodeSpacing;\n        }\n        else {\n            nodeSpacingFunc = () => 0;\n        }\n        if (!nodeSize) {\n            nodeSizeFunc = (d) => {\n                if (d.size) {\n                    if (isArray(d.size)) {\n                        const res = d.size[0] > d.size[1] ? d.size[0] : d.size[1];\n                        return res / 2 + nodeSpacingFunc(d);\n                    }\n                    if (isObject(d.size)) {\n                        const res = d.size.width > d.size.height ? d.size.width : d.size.height;\n                        return res / 2 + nodeSpacingFunc(d);\n                    }\n                    return d.size / 2 + nodeSpacingFunc(d);\n                }\n                return 10 + nodeSpacingFunc(d);\n            };\n        }\n        else if (isFunction(nodeSize)) {\n            nodeSizeFunc = (d) => {\n                const size = nodeSize(d);\n                return size + nodeSpacingFunc(d);\n            };\n        }\n        else if (isArray(nodeSize)) {\n            const larger = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];\n            const radius = larger / 2;\n            nodeSizeFunc = (d) => radius + nodeSpacingFunc(d);\n        }\n        else if (isNumber(nodeSize)) {\n            const radius = nodeSize / 2;\n            nodeSizeFunc = (d) => radius + nodeSpacingFunc(d);\n        }\n        else {\n            nodeSizeFunc = () => 10;\n        }\n        // forceCollide's parameter is a radius\n        simulation.force(\"collisionForce\", d3Force.forceCollide(nodeSizeFunc).strength(collideStrength));\n    }\n    /**\n     * 更新布局配置，但不执行布局\n     * @param {object} cfg 需要更新的配置项\n     */\n    updateCfg(cfg) {\n        const self = this;\n        if (self.ticking) {\n            self.forceSimulation.stop();\n            self.ticking = false;\n        }\n        self.forceSimulation = null;\n        Object.assign(self, cfg);\n    }\n    destroy() {\n        const self = this;\n        if (self.ticking) {\n            self.forceSimulation.stop();\n            self.ticking = false;\n        }\n        self.nodes = null;\n        self.edges = null;\n        self.destroyed = true;\n    }\n}\n// Return total ticks of d3-force simulation\nfunction getSimulationTicks(simulation) {\n    const alphaMin = simulation.alphaMin();\n    const alphaTarget = simulation.alphaTarget();\n    const alpha = simulation.alpha();\n    const totalTicksFloat = Math.log((alphaMin - alphaTarget) / (alpha - alphaTarget)) /\n        Math.log(1 - simulation.alphaDecay());\n    const totalTicks = Math.ceil(totalTicksFloat);\n    return totalTicks;\n}\n// 判断是否运行在web worker里\nfunction isInWorker() {\n    // eslint-disable-next-line no-undef\n    return (typeof WorkerGlobalScope !== \"undefined\" &&\n        self instanceof WorkerGlobalScope);\n}\n//# sourceMappingURL=force.js.map"]},"metadata":{},"sourceType":"module"}