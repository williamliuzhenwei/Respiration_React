{"ast":null,"code":"import _classCallCheck from \"/Users/liuzhenwei/Desktop/Respiration_React/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/liuzhenwei/Desktop/Respiration_React/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/liuzhenwei/Desktop/Respiration_React/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/liuzhenwei/Desktop/Respiration_React/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/**\n * @fileOverview Combo force layout\n * @author shiwu.wyy@antfin.com\n */\nimport { Base } from \"./base\";\nimport { isArray, isNumber, isFunction, traverseTreeUp, isObject, getEdgeTerminal } from \"../util\";\n/**\n * force layout for graph with combos\n */\n\nexport var ComboForceLayout = /*#__PURE__*/function (_Base) {\n  _inherits(ComboForceLayout, _Base);\n\n  var _super = _createSuper(ComboForceLayout);\n\n  function ComboForceLayout(options) {\n    var _this;\n\n    _classCallCheck(this, ComboForceLayout);\n\n    _this = _super.call(this);\n    /** 布局中心 */\n\n    _this.center = [0, 0];\n    /** 停止迭代的最大迭代数 */\n\n    _this.maxIteration = 100;\n    /** 重力大小，影响图的紧凑程度 */\n\n    _this.gravity = 10;\n    /** 群组中心力大小 */\n\n    _this.comboGravity = 10;\n    /** 默认边长度 */\n\n    _this.linkDistance = 10;\n    /** 每次迭代位移的衰减相关参数 */\n\n    _this.alpha = 1;\n    _this.alphaMin = 0.001;\n    _this.alphaDecay = 1 - Math.pow(_this.alphaMin, 1 / 300);\n    _this.alphaTarget = 0;\n    /** 节点运动速度衰减参数 */\n\n    _this.velocityDecay = 0.6;\n    /** 边引力大小 */\n\n    _this.edgeStrength = 0.6;\n    /** 节点引力大小 */\n\n    _this.nodeStrength = 30;\n    /** 是否开启防止重叠 */\n\n    _this.preventOverlap = false;\n    /** 是否开启节点之间的防止重叠 */\n\n    _this.preventNodeOverlap = false;\n    /** 是否开启 Combo 之间的防止重叠 */\n\n    _this.preventComboOverlap = false;\n    /** 防止重叠的碰撞力大小 */\n\n    _this.collideStrength = undefined;\n    /** 防止重叠的碰撞力大小 */\n\n    _this.nodeCollideStrength = 0.5;\n    /** 防止重叠的碰撞力大小 */\n\n    _this.comboCollideStrength = 0.5;\n    /** Combo 最小间距，防止重叠时的间隙 */\n\n    _this.comboSpacing = 20;\n    /** Combo 内部的 padding */\n\n    _this.comboPadding = 10;\n    /** 优化计算斥力的速度，两节点间距超过 optimizeRangeFactor * width 则不再计算斥力和重叠斥力 */\n\n    _this.optimizeRangeFactor = 1;\n    /** 每次迭代的回调函数 */\n\n    _this.onTick = function () {};\n    /** 迭代结束的回调函数 */\n\n\n    _this.onLayoutEnd = function () {};\n    /** 根据边两端节点层级差距的调整引力系数的因子，取值范围 [0, 1]。层级差距越大，引力越小 */\n\n\n    _this.depthAttractiveForceScale = 1;\n    /** 根据边两端节点层级差距的调整斥力系数的因子，取值范围 [1, Infinity]。层级差距越大，斥力越大 */\n\n    _this.depthRepulsiveForceScale = 2;\n    /** 内部计算参数 */\n\n    _this.nodes = [];\n    _this.edges = [];\n    _this.combos = [];\n    _this.comboTrees = [];\n    _this.width = 300;\n    _this.height = 300;\n    _this.bias = [];\n    _this.nodeMap = {};\n    _this.oriComboMap = {};\n    _this.indexMap = {};\n    _this.comboMap = {};\n    _this.previousLayouted = false;\n\n    _this.updateCfg(options);\n\n    return _this;\n  }\n\n  _createClass(ComboForceLayout, [{\n    key: \"getDefaultCfg\",\n    value: function getDefaultCfg() {\n      return {\n        maxIteration: 100,\n        center: [0, 0],\n        gravity: 10,\n        speed: 1,\n        comboGravity: 30,\n        preventOverlap: false,\n        preventComboOverlap: true,\n        preventNodeOverlap: true,\n        nodeSpacing: undefined,\n        collideStrength: undefined,\n        nodeCollideStrength: 0.5,\n        comboCollideStrength: 0.5,\n        comboSpacing: 20,\n        comboPadding: 10,\n        edgeStrength: 0.6,\n        nodeStrength: 30,\n        linkDistance: 10\n      };\n    }\n    /**\n     * 执行布局\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute() {\n      var self = this;\n      var nodes = self.nodes;\n      var center = self.center;\n      self.comboTree = {\n        id: \"comboTreeRoot\",\n        depth: -1,\n        children: self.comboTrees\n      };\n\n      if (!nodes || nodes.length === 0) {\n        if (self.onLayoutEnd) self.onLayoutEnd();\n        return;\n      }\n\n      if (nodes.length === 1) {\n        nodes[0].x = center[0];\n        nodes[0].y = center[1];\n        if (self.onLayoutEnd) self.onLayoutEnd();\n        return;\n      }\n\n      self.initVals(); // layout\n\n      self.run();\n      if (self.onLayoutEnd) self.onLayoutEnd();\n    }\n  }, {\n    key: \"run\",\n    value: function run() {\n      var self = this;\n      var nodes = self.nodes;\n      var maxIteration = self.previousLayouted ? self.maxIteration / 5 : self.maxIteration;\n\n      if (!self.width && typeof window !== \"undefined\") {\n        self.width = window.innerWidth;\n      }\n\n      if (!self.height && typeof window !== \"undefined\") {\n        self.height = window.innerHeight;\n      }\n\n      var center = self.center;\n      var velocityDecay = self.velocityDecay; // init the positions to make the nodes with same combo gather around the combo\n\n      var comboMap = self.comboMap;\n      if (!self.previousLayouted) self.initPos(comboMap); // iterate\n\n      var _loop = function _loop(i) {\n        var displacements = [];\n        nodes.forEach(function (_, j) {\n          displacements[j] = {\n            x: 0,\n            y: 0\n          };\n        });\n        self.applyCalculate(displacements); // gravity for combos\n\n        self.applyComboCenterForce(displacements); // move\n\n        nodes.forEach(function (n, j) {\n          if (!isNumber(n.x) || !isNumber(n.y)) return;\n          n.x += displacements[j].x * velocityDecay;\n          n.y += displacements[j].y * velocityDecay;\n        });\n        self.alpha += (self.alphaTarget - self.alpha) * self.alphaDecay;\n        self.onTick();\n      };\n\n      for (var i = 0; i < maxIteration; i++) {\n        _loop(i);\n      } // move to center\n\n\n      var meanCenter = [0, 0];\n      nodes.forEach(function (n) {\n        if (!isNumber(n.x) || !isNumber(n.y)) return;\n        meanCenter[0] += n.x;\n        meanCenter[1] += n.y;\n      });\n      meanCenter[0] /= nodes.length;\n      meanCenter[1] /= nodes.length;\n      var centerOffset = [center[0] - meanCenter[0], center[1] - meanCenter[1]];\n      nodes.forEach(function (n, j) {\n        if (!isNumber(n.x) || !isNumber(n.y)) return;\n        n.x += centerOffset[0];\n        n.y += centerOffset[1];\n      }); // arrange the empty combo\n\n      self.combos.forEach(function (combo) {\n        var mapped = comboMap[combo.id];\n\n        if (mapped && mapped.empty) {\n          combo.x = mapped.cx || combo.x;\n          combo.y = mapped.cy || combo.y;\n        }\n      });\n      self.previousLayouted = true;\n    }\n  }, {\n    key: \"initVals\",\n    value: function initVals() {\n      var self = this;\n      var edges = self.edges;\n      var nodes = self.nodes;\n      var combos = self.combos;\n      var count = {};\n      var nodeMap = {};\n      var indexMap = {};\n      nodes.forEach(function (node, i) {\n        nodeMap[node.id] = node;\n        indexMap[node.id] = i;\n      });\n      self.nodeMap = nodeMap;\n      self.indexMap = indexMap;\n      var oriComboMap = {};\n      combos.forEach(function (combo) {\n        oriComboMap[combo.id] = combo;\n      });\n      self.oriComboMap = oriComboMap;\n      self.comboMap = self.getComboMap();\n      var preventOverlap = self.preventOverlap;\n      self.preventComboOverlap = self.preventComboOverlap || preventOverlap;\n      self.preventNodeOverlap = self.preventNodeOverlap || preventOverlap;\n      var collideStrength = self.collideStrength;\n\n      if (collideStrength) {\n        self.comboCollideStrength = collideStrength;\n        self.nodeCollideStrength = collideStrength;\n      }\n\n      self.comboCollideStrength = self.comboCollideStrength ? self.comboCollideStrength : 0;\n      self.nodeCollideStrength = self.nodeCollideStrength ? self.nodeCollideStrength : 0; // get edge bias\n\n      for (var i = 0; i < edges.length; ++i) {\n        var source = getEdgeTerminal(edges[i], 'source');\n        var target = getEdgeTerminal(edges[i], 'target');\n        if (count[source]) count[source]++;else count[source] = 1;\n        if (count[target]) count[target]++;else count[target] = 1;\n      }\n\n      var bias = [];\n\n      for (var _i = 0; _i < edges.length; ++_i) {\n        var _source = getEdgeTerminal(edges[_i], 'source');\n\n        var _target = getEdgeTerminal(edges[_i], 'target');\n\n        bias[_i] = count[_source] / (count[_source] + count[_target]);\n      }\n\n      this.bias = bias;\n      var nodeSize = self.nodeSize;\n      var nodeSpacing = self.nodeSpacing;\n      var nodeSizeFunc;\n      var nodeSpacingFunc; // nodeSpacing to function\n\n      if (isNumber(nodeSpacing)) {\n        nodeSpacingFunc = function nodeSpacingFunc() {\n          return nodeSpacing;\n        };\n      } else if (isFunction(nodeSpacing)) {\n        nodeSpacingFunc = nodeSpacing;\n      } else {\n        nodeSpacingFunc = function nodeSpacingFunc() {\n          return 0;\n        };\n      }\n\n      this.nodeSpacing = nodeSpacingFunc; // nodeSize to function\n\n      if (!nodeSize) {\n        nodeSizeFunc = function nodeSizeFunc(d) {\n          if (d.size) {\n            if (isArray(d.size)) {\n              var res = d.size[0] > d.size[1] ? d.size[0] : d.size[1];\n              return res / 2;\n            }\n\n            if (isObject(d.size)) {\n              var _res = d.size.width > d.size.height ? d.size.width : d.size.height;\n\n              return _res / 2;\n            }\n\n            return d.size / 2;\n          }\n\n          return 10;\n        };\n      } else if (isFunction(nodeSize)) {\n        nodeSizeFunc = function nodeSizeFunc(d) {\n          return nodeSize(d);\n        };\n      } else if (isArray(nodeSize)) {\n        var larger = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];\n        var radius = larger / 2;\n\n        nodeSizeFunc = function nodeSizeFunc(d) {\n          return radius;\n        };\n      } else {\n        // number type\n        var _radius = nodeSize / 2;\n\n        nodeSizeFunc = function nodeSizeFunc(d) {\n          return _radius;\n        };\n      }\n\n      this.nodeSize = nodeSizeFunc; // comboSpacing to function\n\n      var comboSpacing = self.comboSpacing;\n      var comboSpacingFunc;\n\n      if (isNumber(comboSpacing)) {\n        comboSpacingFunc = function comboSpacingFunc() {\n          return comboSpacing;\n        };\n      } else if (isFunction(comboSpacing)) {\n        comboSpacingFunc = comboSpacing;\n      } else {\n        // null type\n        comboSpacingFunc = function comboSpacingFunc() {\n          return 0;\n        };\n      }\n\n      this.comboSpacing = comboSpacingFunc; // comboPadding to function\n\n      var comboPadding = self.comboPadding;\n      var comboPaddingFunc;\n\n      if (isNumber(comboPadding)) {\n        comboPaddingFunc = function comboPaddingFunc() {\n          return comboPadding;\n        };\n      } else if (isArray(comboPadding)) {\n        comboPaddingFunc = function comboPaddingFunc() {\n          return Math.max.apply(null, comboPadding);\n        };\n      } else if (isFunction(comboPadding)) {\n        comboPaddingFunc = comboPadding;\n      } else {\n        // null type\n        comboPaddingFunc = function comboPaddingFunc() {\n          return 0;\n        };\n      }\n\n      this.comboPadding = comboPaddingFunc; // linkDistance to function\n\n      var linkDistance = this.linkDistance;\n      var linkDistanceFunc;\n\n      if (!linkDistance) {\n        linkDistance = 10;\n      }\n\n      if (isNumber(linkDistance)) {\n        linkDistanceFunc = function linkDistanceFunc(d) {\n          return linkDistance;\n        };\n      } else {\n        linkDistanceFunc = linkDistance;\n      }\n\n      this.linkDistance = linkDistanceFunc; // linkStrength to function\n\n      var edgeStrength = this.edgeStrength;\n      var edgeStrengthFunc;\n\n      if (!edgeStrength) {\n        edgeStrength = 1;\n      }\n\n      if (isNumber(edgeStrength)) {\n        edgeStrengthFunc = function edgeStrengthFunc(d) {\n          return edgeStrength;\n        };\n      } else {\n        edgeStrengthFunc = edgeStrength;\n      }\n\n      this.edgeStrength = edgeStrengthFunc; // nodeStrength to function\n\n      var nodeStrength = this.nodeStrength;\n      var nodeStrengthFunc;\n\n      if (!nodeStrength) {\n        nodeStrength = 30;\n      }\n\n      if (isNumber(nodeStrength)) {\n        nodeStrengthFunc = function nodeStrengthFunc(d) {\n          return nodeStrength;\n        };\n      } else {\n        nodeStrengthFunc = nodeStrength;\n      }\n\n      this.nodeStrength = nodeStrengthFunc;\n    }\n  }, {\n    key: \"initPos\",\n    value: function initPos(comboMap) {\n      var self = this;\n      var nodes = self.nodes;\n      nodes.forEach(function (node, i) {\n        var comboId = node.comboId;\n        var combo = comboMap[comboId];\n\n        if (comboId && combo) {\n          node.x = combo.cx + 100 / (i + 1);\n          node.y = combo.cy + 100 / (i + 1);\n        } else {\n          node.x = 100 / (i + 1);\n          node.y = 100 / (i + 1);\n        }\n      });\n    }\n  }, {\n    key: \"getComboMap\",\n    value: function getComboMap() {\n      var self = this;\n      var nodeMap = self.nodeMap;\n      var indexMap = self.indexMap;\n      var comboTrees = self.comboTrees;\n      var oriComboMap = self.oriComboMap;\n      var comboMap = {};\n      (comboTrees || []).forEach(function (ctree) {\n        var treeChildren = [];\n        traverseTreeUp(ctree, function (treeNode) {\n          if (treeNode.itemType === \"node\") return true; // skip it\n\n          if (!oriComboMap[treeNode.id]) return true; // means it is hidden, skip it\n\n          if (comboMap[treeNode.id] === undefined) {\n            var combo = {\n              id: treeNode.id,\n              name: treeNode.id,\n              cx: 0,\n              cy: 0,\n              count: 0,\n              depth: self.oriComboMap[treeNode.id].depth || 0,\n              children: []\n            };\n            comboMap[treeNode.id] = combo;\n          }\n\n          var children = treeNode.children;\n\n          if (children) {\n            children.forEach(function (child) {\n              if (!comboMap[child.id] && !nodeMap[child.id]) return true; // means it is hidden\n\n              treeChildren.push(child);\n            });\n          }\n\n          var c = comboMap[treeNode.id];\n          c.cx = 0;\n          c.cy = 0; // In order to layout the empty combo, add a virtual node to it\n\n          if (treeChildren.length === 0) {\n            c.empty = true;\n            var oriCombo = oriComboMap[treeNode.id];\n            var idx = Object.keys(nodeMap).length;\n            var virtualNodeId = \"\".concat(treeNode.id, \"-visual-child-\").concat(idx);\n            var vnode = {\n              id: virtualNodeId,\n              x: oriCombo.x,\n              y: oriCombo.y,\n              depth: c.depth + 1,\n              itemType: \"node\"\n            };\n            self.nodes.push(vnode);\n            nodeMap[virtualNodeId] = vnode;\n            indexMap[virtualNodeId] = idx;\n            c.cx = oriCombo.x;\n            c.cy = oriCombo.y;\n            treeChildren.push(vnode);\n          }\n\n          treeChildren.forEach(function (child) {\n            c.count++;\n\n            if (child.itemType !== \"node\") {\n              var childCombo = comboMap[child.id];\n              if (isNumber(childCombo.cx)) c.cx += childCombo.cx;\n              if (isNumber(childCombo.cy)) c.cy += childCombo.cy;\n              return;\n            }\n\n            var node = nodeMap[child.id]; // means the node is hidden, skip it\n\n            if (!node) return;\n\n            if (isNumber(node.x)) {\n              c.cx += node.x;\n            }\n\n            if (isNumber(node.y)) {\n              c.cy += node.y;\n            }\n          });\n          c.cx /= c.count;\n          c.cy /= c.count;\n          c.children = treeChildren;\n          return true;\n        });\n      });\n      return comboMap;\n    }\n  }, {\n    key: \"applyComboCenterForce\",\n    value: function applyComboCenterForce(displacements) {\n      var self = this;\n      var gravity = self.gravity;\n      var comboGravity = self.comboGravity || gravity;\n      var alpha = this.alpha;\n      var comboTrees = self.comboTrees;\n      var indexMap = self.indexMap;\n      var nodeMap = self.nodeMap;\n      var comboMap = self.comboMap;\n      (comboTrees || []).forEach(function (ctree) {\n        traverseTreeUp(ctree, function (treeNode) {\n          if (treeNode.itemType === \"node\") return true; // skip it\n\n          var combo = comboMap[treeNode.id]; // means the combo is hidden, skip it\n\n          if (!combo) return true;\n          var c = comboMap[treeNode.id]; // higher depth the combo, larger the gravity\n\n          var gravityScale = (c.depth + 1) / 10 * 0.5; // apply combo center force for all the descend nodes in this combo\n          // and update the center position and count for this combo\n\n          var comboX = c.cx;\n          var comboY = c.cy;\n          c.cx = 0;\n          c.cy = 0;\n          c.children.forEach(function (child) {\n            if (child.itemType !== \"node\") {\n              var childCombo = comboMap[child.id];\n              if (childCombo && isNumber(childCombo.cx)) c.cx += childCombo.cx;\n              if (childCombo && isNumber(childCombo.cy)) c.cy += childCombo.cy;\n              return;\n            }\n\n            var node = nodeMap[child.id];\n            var vecX = node.x - comboX || 0.005;\n            var vecY = node.y - comboY || 0.005;\n            var l = Math.sqrt(vecX * vecX + vecY * vecY);\n            var childIdx = indexMap[node.id];\n            var params = comboGravity * alpha / l * gravityScale;\n            displacements[childIdx].x -= vecX * params;\n            displacements[childIdx].y -= vecY * params;\n            if (isNumber(node.x)) c.cx += node.x;\n            if (isNumber(node.y)) c.cy += node.y;\n          });\n          c.cx /= c.count;\n          c.cy /= c.count;\n          return true;\n        });\n      });\n    }\n  }, {\n    key: \"applyCalculate\",\n    value: function applyCalculate(displacements) {\n      var self = this;\n      var comboMap = self.comboMap;\n      var nodes = self.nodes; // store the vx, vy, and distance to reduce dulplicate calculation\n\n      var vecMap = {};\n      nodes.forEach(function (v, i) {\n        nodes.forEach(function (u, j) {\n          if (i < j) return;\n          var vx = v.x - u.x || 0.005;\n          var vy = v.y - u.y || 0.005;\n          var vl2 = vx * vx + vy * vy;\n          var vl = Math.sqrt(vl2);\n          if (vl2 < 1) vl2 = vl;\n          vecMap[\"\".concat(v.id, \"-\").concat(u.id)] = {\n            vx: vx,\n            vy: vy,\n            vl2: vl2,\n            vl: vl\n          };\n          vecMap[\"\".concat(u.id, \"-\").concat(v.id)] = {\n            vl2: vl2,\n            vl: vl,\n            vx: -vx,\n            vy: -vy\n          };\n        });\n      }); // get the sizes of the combos\n\n      self.updateComboSizes(comboMap);\n      self.calRepulsive(displacements, vecMap);\n      self.calAttractive(displacements, vecMap);\n      var preventComboOverlap = self.preventComboOverlap;\n      if (preventComboOverlap) self.comboNonOverlapping(displacements, comboMap);\n    }\n    /**\n     * Update the sizes of the combos according to their children\n     * Used for combos nonoverlap, but not re-render the combo shapes\n     */\n\n  }, {\n    key: \"updateComboSizes\",\n    value: function updateComboSizes(comboMap) {\n      var self = this;\n      var comboTrees = self.comboTrees;\n      var nodeMap = self.nodeMap;\n      var nodeSize = self.nodeSize;\n      var comboSpacing = self.comboSpacing;\n      var comboPadding = self.comboPadding;\n      (comboTrees || []).forEach(function (ctree) {\n        var treeChildren = [];\n        traverseTreeUp(ctree, function (treeNode) {\n          if (treeNode.itemType === \"node\") return true; // skip it\n\n          var c = comboMap[treeNode.id]; // means the combo is hidden, skip it\n\n          if (!c) return false;\n          var children = treeNode.children;\n\n          if (children) {\n            children.forEach(function (child) {\n              // means the combo is hidden.\n              if (!comboMap[child.id] && !nodeMap[child.id]) return;\n              treeChildren.push(child);\n            });\n          }\n\n          c.minX = Infinity;\n          c.minY = Infinity;\n          c.maxX = -Infinity;\n          c.maxY = -Infinity;\n          treeChildren.forEach(function (child) {\n            if (child.itemType !== \"node\") return true; // skip it\n\n            var node = nodeMap[child.id];\n            if (!node) return true; // means it is hidden\n\n            var r = nodeSize(node);\n            var nodeMinX = node.x - r;\n            var nodeMinY = node.y - r;\n            var nodeMaxX = node.x + r;\n            var nodeMaxY = node.y + r;\n            if (c.minX > nodeMinX) c.minX = nodeMinX;\n            if (c.minY > nodeMinY) c.minY = nodeMinY;\n            if (c.maxX < nodeMaxX) c.maxX = nodeMaxX;\n            if (c.maxY < nodeMaxY) c.maxY = nodeMaxY;\n          });\n          var minSize = self.oriComboMap[treeNode.id].size || 10;\n          if (isArray(minSize)) minSize = minSize[0];\n          var maxLength = Math.max(c.maxX - c.minX, c.maxY - c.minY, minSize);\n          c.r = maxLength / 2 + comboSpacing(c) / 2 + comboPadding(c);\n          return true;\n        });\n      });\n    }\n    /**\n     * prevent the overlappings among combos\n     */\n\n  }, {\n    key: \"comboNonOverlapping\",\n    value: function comboNonOverlapping(displacements, comboMap) {\n      var self = this;\n      var comboTree = self.comboTree;\n      var comboCollideStrength = self.comboCollideStrength;\n      var indexMap = self.indexMap;\n      var nodeMap = self.nodeMap;\n      traverseTreeUp(comboTree, function (treeNode) {\n        if (!comboMap[treeNode.id] && !nodeMap[treeNode.id] && treeNode.id !== \"comboTreeRoot\") {\n          return false;\n        } // means it is hidden\n\n\n        var children = treeNode.children; // 同个子树下的子 combo 间两两对比\n\n        if (children && children.length > 1) {\n          children.forEach(function (v, i) {\n            if (v.itemType === \"node\") return false; // skip it\n\n            var cv = comboMap[v.id];\n            if (!cv) return; // means it is hidden, skip it\n\n            children.forEach(function (u, j) {\n              if (i <= j) return false;\n              if (u.itemType === \"node\") return false; // skip it\n\n              var cu = comboMap[u.id];\n              if (!cu) return false; // means it is hidden, skip it\n\n              var vx = cv.cx - cu.cx || 0.005;\n              var vy = cv.cy - cu.cy || 0.005;\n              var l = vx * vx + vy * vy;\n              var rv = cv.r || 1;\n              var ru = cu.r || 1;\n              var r = rv + ru;\n              var ru2 = ru * ru;\n              var rv2 = rv * rv; // overlapping\n\n              if (l < r * r) {\n                var vnodes = v.children;\n                if (!vnodes || vnodes.length === 0) return false; // skip it\n\n                var unodes = u.children;\n                if (!unodes || unodes.length === 0) return false; // skip it\n\n                var sqrtl = Math.sqrt(l);\n                var ll = (r - sqrtl) / sqrtl * comboCollideStrength;\n                var xl = vx * ll;\n                var yl = vy * ll;\n                var rratio = ru2 / (rv2 + ru2);\n                var irratio = 1 - rratio; // 两兄弟 combo 的子节点上施加斥力\n\n                vnodes.forEach(function (vn) {\n                  if (vn.itemType !== \"node\") return false; // skip it\n\n                  if (!nodeMap[vn.id]) return; // means it is hidden, skip it\n\n                  var vindex = indexMap[vn.id];\n                  unodes.forEach(function (un) {\n                    if (un.itemType !== \"node\") return false;\n                    if (!nodeMap[un.id]) return false; // means it is hidden, skip it\n\n                    var uindex = indexMap[un.id];\n                    displacements[vindex].x += xl * rratio;\n                    displacements[vindex].y += yl * rratio;\n                    displacements[uindex].x -= xl * irratio;\n                    displacements[uindex].y -= yl * irratio;\n                  });\n                });\n              }\n            });\n          });\n        }\n\n        return true;\n      });\n    }\n    /**\n     * Calculate the repulsive force between each node pair\n     * @param displacements The array stores the displacements for nodes\n     * @param vecMap The map stores vector between each node pair\n     */\n\n  }, {\n    key: \"calRepulsive\",\n    value: function calRepulsive(displacements, vecMap) {\n      var self = this;\n      var nodes = self.nodes;\n      var max = self.width * self.optimizeRangeFactor;\n      var nodeStrength = self.nodeStrength;\n      var alpha = self.alpha;\n      var nodeCollideStrength = self.nodeCollideStrength;\n      var preventNodeOverlap = self.preventNodeOverlap;\n      var nodeSizeFunc = self.nodeSize;\n      var nodeSpacingFunc = self.nodeSpacing;\n      var scale = self.depthRepulsiveForceScale;\n      var center = self.center;\n      nodes.forEach(function (v, i) {\n        if (!v.x || !v.y) return; // center gravity\n\n        if (center) {\n          var gravity = self.gravity;\n          var vecX = v.x - center[0] || 0.005;\n          var vecY = v.y - center[1] || 0.005;\n          var l = Math.sqrt(vecX * vecX + vecY * vecY);\n          displacements[i].x -= vecX * gravity * alpha / l;\n          displacements[i].y -= vecY * gravity * alpha / l;\n        }\n\n        nodes.forEach(function (u, j) {\n          if (i === j) {\n            return;\n          }\n\n          if (!u.x || !u.y) return;\n          var _vecMap$ = vecMap[\"\".concat(v.id, \"-\").concat(u.id)],\n              vl2 = _vecMap$.vl2,\n              vl = _vecMap$.vl;\n          if (vl > max) return;\n          var _vecMap$2 = vecMap[\"\".concat(v.id, \"-\").concat(u.id)],\n              vx = _vecMap$2.vx,\n              vy = _vecMap$2.vy;\n          var depthDiff = Math.log(Math.abs(u.depth - v.depth) / 10) + 1 || 1;\n          depthDiff = depthDiff < 1 ? 1 : depthDiff;\n          if (u.comboId !== v.comboId) depthDiff += 1;\n          var depthParam = depthDiff ? Math.pow(scale, depthDiff) : 1;\n          var params = nodeStrength(u) * alpha / vl2 * depthParam;\n          displacements[i].x += vx * params;\n          displacements[i].y += vy * params; // prevent node overlappings\n\n          if (i < j && preventNodeOverlap) {\n            var ri = nodeSizeFunc(v) + nodeSpacingFunc(v) || 1;\n            var rj = nodeSizeFunc(u) + nodeSpacingFunc(u) || 1;\n            var r = ri + rj;\n\n            if (vl2 < r * r) {\n              var ll = (r - vl) / vl * nodeCollideStrength;\n              var rj2 = rj * rj;\n              var rratio = rj2 / (ri * ri + rj2);\n              var xl = vx * ll;\n              var yl = vy * ll;\n              displacements[i].x += xl * rratio;\n              displacements[i].y += yl * rratio;\n              rratio = 1 - rratio;\n              displacements[j].x -= xl * rratio;\n              displacements[j].y -= yl * rratio;\n            }\n          }\n        });\n      });\n    }\n    /**\n     * Calculate the attractive force between the node pair with edge\n     * @param displacements The array stores the displacements for nodes\n     * @param vecMap The map stores vector between each node pair\n     */\n\n  }, {\n    key: \"calAttractive\",\n    value: function calAttractive(displacements, vecMap) {\n      var self = this;\n      var edges = self.edges;\n      var linkDistance = self.linkDistance;\n      var alpha = self.alpha;\n      var edgeStrength = self.edgeStrength;\n      var bias = self.bias;\n      var scale = self.depthAttractiveForceScale;\n      edges.forEach(function (e, i) {\n        var source = getEdgeTerminal(e, 'source');\n        var target = getEdgeTerminal(e, 'target');\n        if (!source || !target || source === target) return;\n        var uIndex = self.indexMap[source];\n        var vIndex = self.indexMap[target];\n        var u = self.nodeMap[source];\n        var v = self.nodeMap[target];\n        if (!u || !v) return;\n        var depthDiff = u.depth === v.depth ? 0 : Math.log(Math.abs(u.depth - v.depth) / 10);\n\n        if (u.comboId === v.comboId) {\n          depthDiff = depthDiff / 2;\n        }\n\n        var depthParam = depthDiff ? Math.pow(scale, depthDiff) : 1;\n\n        if (u.comboId !== v.comboId && depthParam === 1) {\n          depthParam = scale / 2;\n        } else if (u.comboId === v.comboId) {\n          depthParam = 2;\n        }\n\n        if (!isNumber(v.x) || !isNumber(u.x) || !isNumber(v.y) || !isNumber(u.y)) {\n          return;\n        }\n\n        var _vecMap$3 = vecMap[\"\".concat(target, \"-\").concat(source)],\n            vl = _vecMap$3.vl,\n            vx = _vecMap$3.vx,\n            vy = _vecMap$3.vy;\n        var l = (vl - linkDistance(e)) / vl * alpha * edgeStrength(e) * depthParam;\n        var vecX = vx * l;\n        var vecY = vy * l;\n        var b = bias[i];\n        displacements[vIndex].x -= vecX * b;\n        displacements[vIndex].y -= vecY * b;\n        displacements[uIndex].x += vecX * (1 - b);\n        displacements[uIndex].y += vecY * (1 - b);\n      });\n    }\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      return \"comboForce\";\n    }\n  }]);\n\n  return ComboForceLayout;\n}(Base);","map":{"version":3,"sources":["../../src/layout/comboForce.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @fileOverview Combo force layout\n * @author shiwu.wyy@antfin.com\n */\nimport { Base } from \"./base\";\nimport { isArray, isNumber, isFunction, traverseTreeUp, isObject, getEdgeTerminal } from \"../util\";\n/**\n * force layout for graph with combos\n */\nexport class ComboForceLayout extends Base {\n    constructor(options) {\n        super();\n        /** 布局中心 */\n        this.center = [0, 0];\n        /** 停止迭代的最大迭代数 */\n        this.maxIteration = 100;\n        /** 重力大小，影响图的紧凑程度 */\n        this.gravity = 10;\n        /** 群组中心力大小 */\n        this.comboGravity = 10;\n        /** 默认边长度 */\n        this.linkDistance = 10;\n        /** 每次迭代位移的衰减相关参数 */\n        this.alpha = 1;\n        this.alphaMin = 0.001;\n        this.alphaDecay = 1 - Math.pow(this.alphaMin, (1 / 300));\n        this.alphaTarget = 0;\n        /** 节点运动速度衰减参数 */\n        this.velocityDecay = 0.6;\n        /** 边引力大小 */\n        this.edgeStrength = 0.6;\n        /** 节点引力大小 */\n        this.nodeStrength = 30;\n        /** 是否开启防止重叠 */\n        this.preventOverlap = false;\n        /** 是否开启节点之间的防止重叠 */\n        this.preventNodeOverlap = false;\n        /** 是否开启 Combo 之间的防止重叠 */\n        this.preventComboOverlap = false;\n        /** 防止重叠的碰撞力大小 */\n        this.collideStrength = undefined;\n        /** 防止重叠的碰撞力大小 */\n        this.nodeCollideStrength = 0.5;\n        /** 防止重叠的碰撞力大小 */\n        this.comboCollideStrength = 0.5;\n        /** Combo 最小间距，防止重叠时的间隙 */\n        this.comboSpacing = 20;\n        /** Combo 内部的 padding */\n        this.comboPadding = 10;\n        /** 优化计算斥力的速度，两节点间距超过 optimizeRangeFactor * width 则不再计算斥力和重叠斥力 */\n        this.optimizeRangeFactor = 1;\n        /** 每次迭代的回调函数 */\n        this.onTick = () => { };\n        /** 迭代结束的回调函数 */\n        this.onLayoutEnd = () => { };\n        /** 根据边两端节点层级差距的调整引力系数的因子，取值范围 [0, 1]。层级差距越大，引力越小 */\n        this.depthAttractiveForceScale = 1;\n        /** 根据边两端节点层级差距的调整斥力系数的因子，取值范围 [1, Infinity]。层级差距越大，斥力越大 */\n        this.depthRepulsiveForceScale = 2;\n        /** 内部计算参数 */\n        this.nodes = [];\n        this.edges = [];\n        this.combos = [];\n        this.comboTrees = [];\n        this.width = 300;\n        this.height = 300;\n        this.bias = [];\n        this.nodeMap = {};\n        this.oriComboMap = {};\n        this.indexMap = {};\n        this.comboMap = {};\n        this.previousLayouted = false;\n        this.updateCfg(options);\n    }\n    getDefaultCfg() {\n        return {\n            maxIteration: 100,\n            center: [0, 0],\n            gravity: 10,\n            speed: 1,\n            comboGravity: 30,\n            preventOverlap: false,\n            preventComboOverlap: true,\n            preventNodeOverlap: true,\n            nodeSpacing: undefined,\n            collideStrength: undefined,\n            nodeCollideStrength: 0.5,\n            comboCollideStrength: 0.5,\n            comboSpacing: 20,\n            comboPadding: 10,\n            edgeStrength: 0.6,\n            nodeStrength: 30,\n            linkDistance: 10\n        };\n    }\n    /**\n     * 执行布局\n     */\n    execute() {\n        const self = this;\n        const nodes = self.nodes;\n        const center = self.center;\n        self.comboTree = {\n            id: \"comboTreeRoot\",\n            depth: -1,\n            children: self.comboTrees\n        };\n        if (!nodes || nodes.length === 0) {\n            if (self.onLayoutEnd)\n                self.onLayoutEnd();\n            return;\n        }\n        if (nodes.length === 1) {\n            nodes[0].x = center[0];\n            nodes[0].y = center[1];\n            if (self.onLayoutEnd)\n                self.onLayoutEnd();\n            return;\n        }\n        self.initVals();\n        // layout\n        self.run();\n        if (self.onLayoutEnd)\n            self.onLayoutEnd();\n    }\n    run() {\n        const self = this;\n        const nodes = self.nodes;\n        const maxIteration = self.previousLayouted\n            ? self.maxIteration / 5\n            : self.maxIteration;\n        if (!self.width && typeof window !== \"undefined\") {\n            self.width = window.innerWidth;\n        }\n        if (!self.height && typeof window !== \"undefined\") {\n            self.height = window.innerHeight;\n        }\n        const center = self.center;\n        const velocityDecay = self.velocityDecay;\n        // init the positions to make the nodes with same combo gather around the combo\n        const comboMap = self.comboMap;\n        if (!self.previousLayouted)\n            self.initPos(comboMap);\n        // iterate\n        for (let i = 0; i < maxIteration; i++) {\n            const displacements = [];\n            nodes.forEach((_, j) => {\n                displacements[j] = { x: 0, y: 0 };\n            });\n            self.applyCalculate(displacements);\n            // gravity for combos\n            self.applyComboCenterForce(displacements);\n            // move\n            nodes.forEach((n, j) => {\n                if (!isNumber(n.x) || !isNumber(n.y))\n                    return;\n                n.x += displacements[j].x * velocityDecay;\n                n.y += displacements[j].y * velocityDecay;\n            });\n            self.alpha += (self.alphaTarget - self.alpha) * self.alphaDecay;\n            self.onTick();\n        }\n        // move to center\n        const meanCenter = [0, 0];\n        nodes.forEach((n) => {\n            if (!isNumber(n.x) || !isNumber(n.y))\n                return;\n            meanCenter[0] += n.x;\n            meanCenter[1] += n.y;\n        });\n        meanCenter[0] /= nodes.length;\n        meanCenter[1] /= nodes.length;\n        const centerOffset = [center[0] - meanCenter[0], center[1] - meanCenter[1]];\n        nodes.forEach((n, j) => {\n            if (!isNumber(n.x) || !isNumber(n.y))\n                return;\n            n.x += centerOffset[0];\n            n.y += centerOffset[1];\n        });\n        // arrange the empty combo\n        self.combos.forEach((combo) => {\n            const mapped = comboMap[combo.id];\n            if (mapped && mapped.empty) {\n                combo.x = mapped.cx || combo.x;\n                combo.y = mapped.cy || combo.y;\n            }\n        });\n        self.previousLayouted = true;\n    }\n    initVals() {\n        const self = this;\n        const edges = self.edges;\n        const nodes = self.nodes;\n        const combos = self.combos;\n        const count = {};\n        const nodeMap = {};\n        const indexMap = {};\n        nodes.forEach((node, i) => {\n            nodeMap[node.id] = node;\n            indexMap[node.id] = i;\n        });\n        self.nodeMap = nodeMap;\n        self.indexMap = indexMap;\n        const oriComboMap = {};\n        combos.forEach((combo) => {\n            oriComboMap[combo.id] = combo;\n        });\n        self.oriComboMap = oriComboMap;\n        self.comboMap = self.getComboMap();\n        const preventOverlap = self.preventOverlap;\n        self.preventComboOverlap = self.preventComboOverlap || preventOverlap;\n        self.preventNodeOverlap = self.preventNodeOverlap || preventOverlap;\n        const collideStrength = self.collideStrength;\n        if (collideStrength) {\n            self.comboCollideStrength = collideStrength;\n            self.nodeCollideStrength = collideStrength;\n        }\n        self.comboCollideStrength = self.comboCollideStrength\n            ? self.comboCollideStrength\n            : 0;\n        self.nodeCollideStrength = self.nodeCollideStrength\n            ? self.nodeCollideStrength\n            : 0;\n        // get edge bias\n        for (let i = 0; i < edges.length; ++i) {\n            const source = getEdgeTerminal(edges[i], 'source');\n            const target = getEdgeTerminal(edges[i], 'target');\n            if (count[source])\n                count[source]++;\n            else\n                count[source] = 1;\n            if (count[target])\n                count[target]++;\n            else\n                count[target] = 1;\n        }\n        const bias = [];\n        for (let i = 0; i < edges.length; ++i) {\n            const source = getEdgeTerminal(edges[i], 'source');\n            const target = getEdgeTerminal(edges[i], 'target');\n            bias[i] = count[source] / (count[source] + count[target]);\n        }\n        this.bias = bias;\n        const nodeSize = self.nodeSize;\n        const nodeSpacing = self.nodeSpacing;\n        let nodeSizeFunc;\n        let nodeSpacingFunc;\n        // nodeSpacing to function\n        if (isNumber(nodeSpacing)) {\n            nodeSpacingFunc = () => nodeSpacing;\n        }\n        else if (isFunction(nodeSpacing)) {\n            nodeSpacingFunc = nodeSpacing;\n        }\n        else {\n            nodeSpacingFunc = () => 0;\n        }\n        this.nodeSpacing = nodeSpacingFunc;\n        // nodeSize to function\n        if (!nodeSize) {\n            nodeSizeFunc = (d) => {\n                if (d.size) {\n                    if (isArray(d.size)) {\n                        const res = d.size[0] > d.size[1] ? d.size[0] : d.size[1];\n                        return res / 2;\n                    }\n                    if (isObject(d.size)) {\n                        const res = d.size.width > d.size.height ? d.size.width : d.size.height;\n                        return res / 2;\n                    }\n                    return d.size / 2;\n                }\n                return 10;\n            };\n        }\n        else if (isFunction(nodeSize)) {\n            nodeSizeFunc = (d) => {\n                return nodeSize(d);\n            };\n        }\n        else if (isArray(nodeSize)) {\n            const larger = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];\n            const radius = larger / 2;\n            nodeSizeFunc = (d) => radius;\n        }\n        else {\n            // number type\n            const radius = nodeSize / 2;\n            nodeSizeFunc = (d) => radius;\n        }\n        this.nodeSize = nodeSizeFunc;\n        // comboSpacing to function\n        const comboSpacing = self.comboSpacing;\n        let comboSpacingFunc;\n        if (isNumber(comboSpacing)) {\n            comboSpacingFunc = () => comboSpacing;\n        }\n        else if (isFunction(comboSpacing)) {\n            comboSpacingFunc = comboSpacing;\n        }\n        else {\n            // null type\n            comboSpacingFunc = () => 0;\n        }\n        this.comboSpacing = comboSpacingFunc;\n        // comboPadding to function\n        const comboPadding = self.comboPadding;\n        let comboPaddingFunc;\n        if (isNumber(comboPadding)) {\n            comboPaddingFunc = () => comboPadding;\n        }\n        else if (isArray(comboPadding)) {\n            comboPaddingFunc = () => Math.max.apply(null, comboPadding);\n        }\n        else if (isFunction(comboPadding)) {\n            comboPaddingFunc = comboPadding;\n        }\n        else {\n            // null type\n            comboPaddingFunc = () => 0;\n        }\n        this.comboPadding = comboPaddingFunc;\n        // linkDistance to function\n        let linkDistance = this.linkDistance;\n        let linkDistanceFunc;\n        if (!linkDistance) {\n            linkDistance = 10;\n        }\n        if (isNumber(linkDistance)) {\n            linkDistanceFunc = (d) => {\n                return linkDistance;\n            };\n        }\n        else {\n            linkDistanceFunc = linkDistance;\n        }\n        this.linkDistance = linkDistanceFunc;\n        // linkStrength to function\n        let edgeStrength = this.edgeStrength;\n        let edgeStrengthFunc;\n        if (!edgeStrength) {\n            edgeStrength = 1;\n        }\n        if (isNumber(edgeStrength)) {\n            edgeStrengthFunc = (d) => {\n                return edgeStrength;\n            };\n        }\n        else {\n            edgeStrengthFunc = edgeStrength;\n        }\n        this.edgeStrength = edgeStrengthFunc;\n        // nodeStrength to function\n        let nodeStrength = this.nodeStrength;\n        let nodeStrengthFunc;\n        if (!nodeStrength) {\n            nodeStrength = 30;\n        }\n        if (isNumber(nodeStrength)) {\n            nodeStrengthFunc = (d) => {\n                return nodeStrength;\n            };\n        }\n        else {\n            nodeStrengthFunc = nodeStrength;\n        }\n        this.nodeStrength = nodeStrengthFunc;\n    }\n    initPos(comboMap) {\n        const self = this;\n        const nodes = self.nodes;\n        nodes.forEach((node, i) => {\n            const comboId = node.comboId;\n            const combo = comboMap[comboId];\n            if (comboId && combo) {\n                node.x = combo.cx + 100 / (i + 1);\n                node.y = combo.cy + 100 / (i + 1);\n            }\n            else {\n                node.x = 100 / (i + 1);\n                node.y = 100 / (i + 1);\n            }\n        });\n    }\n    getComboMap() {\n        const self = this;\n        const nodeMap = self.nodeMap;\n        const indexMap = self.indexMap;\n        const comboTrees = self.comboTrees;\n        const oriComboMap = self.oriComboMap;\n        const comboMap = {};\n        (comboTrees || []).forEach((ctree) => {\n            const treeChildren = [];\n            traverseTreeUp(ctree, (treeNode) => {\n                if (treeNode.itemType === \"node\")\n                    return true; // skip it\n                if (!oriComboMap[treeNode.id])\n                    return true; // means it is hidden, skip it\n                if (comboMap[treeNode.id] === undefined) {\n                    const combo = {\n                        id: treeNode.id,\n                        name: treeNode.id,\n                        cx: 0,\n                        cy: 0,\n                        count: 0,\n                        depth: self.oriComboMap[treeNode.id].depth || 0,\n                        children: []\n                    };\n                    comboMap[treeNode.id] = combo;\n                }\n                const children = treeNode.children;\n                if (children) {\n                    children.forEach((child) => {\n                        if (!comboMap[child.id] && !nodeMap[child.id])\n                            return true; // means it is hidden\n                        treeChildren.push(child);\n                    });\n                }\n                const c = comboMap[treeNode.id];\n                c.cx = 0;\n                c.cy = 0;\n                // In order to layout the empty combo, add a virtual node to it\n                if (treeChildren.length === 0) {\n                    c.empty = true;\n                    const oriCombo = oriComboMap[treeNode.id];\n                    const idx = Object.keys(nodeMap).length;\n                    const virtualNodeId = `${treeNode.id}-visual-child-${idx}`;\n                    const vnode = {\n                        id: virtualNodeId,\n                        x: oriCombo.x,\n                        y: oriCombo.y,\n                        depth: c.depth + 1,\n                        itemType: \"node\"\n                    };\n                    self.nodes.push(vnode);\n                    nodeMap[virtualNodeId] = vnode;\n                    indexMap[virtualNodeId] = idx;\n                    c.cx = oriCombo.x;\n                    c.cy = oriCombo.y;\n                    treeChildren.push(vnode);\n                }\n                treeChildren.forEach((child) => {\n                    c.count++;\n                    if (child.itemType !== \"node\") {\n                        const childCombo = comboMap[child.id];\n                        if (isNumber(childCombo.cx))\n                            c.cx += childCombo.cx;\n                        if (isNumber(childCombo.cy))\n                            c.cy += childCombo.cy;\n                        return;\n                    }\n                    const node = nodeMap[child.id];\n                    // means the node is hidden, skip it\n                    if (!node)\n                        return;\n                    if (isNumber(node.x)) {\n                        c.cx += node.x;\n                    }\n                    if (isNumber(node.y)) {\n                        c.cy += node.y;\n                    }\n                });\n                c.cx /= c.count;\n                c.cy /= c.count;\n                c.children = treeChildren;\n                return true;\n            });\n        });\n        return comboMap;\n    }\n    applyComboCenterForce(displacements) {\n        const self = this;\n        const gravity = self.gravity;\n        const comboGravity = self.comboGravity || gravity;\n        const alpha = this.alpha;\n        const comboTrees = self.comboTrees;\n        const indexMap = self.indexMap;\n        const nodeMap = self.nodeMap;\n        const comboMap = self.comboMap;\n        (comboTrees || []).forEach((ctree) => {\n            traverseTreeUp(ctree, (treeNode) => {\n                if (treeNode.itemType === \"node\")\n                    return true; // skip it\n                const combo = comboMap[treeNode.id];\n                // means the combo is hidden, skip it\n                if (!combo)\n                    return true;\n                const c = comboMap[treeNode.id];\n                // higher depth the combo, larger the gravity\n                const gravityScale = ((c.depth + 1) / 10) * 0.5;\n                // apply combo center force for all the descend nodes in this combo\n                // and update the center position and count for this combo\n                const comboX = c.cx;\n                const comboY = c.cy;\n                c.cx = 0;\n                c.cy = 0;\n                c.children.forEach((child) => {\n                    if (child.itemType !== \"node\") {\n                        const childCombo = comboMap[child.id];\n                        if (childCombo && isNumber(childCombo.cx))\n                            c.cx += childCombo.cx;\n                        if (childCombo && isNumber(childCombo.cy))\n                            c.cy += childCombo.cy;\n                        return;\n                    }\n                    const node = nodeMap[child.id];\n                    const vecX = (node.x - comboX) || 0.005;\n                    const vecY = (node.y - comboY) || 0.005;\n                    const l = Math.sqrt(vecX * vecX + vecY * vecY);\n                    const childIdx = indexMap[node.id];\n                    const params = ((comboGravity * alpha) / l) * gravityScale;\n                    displacements[childIdx].x -= vecX * params;\n                    displacements[childIdx].y -= vecY * params;\n                    if (isNumber(node.x))\n                        c.cx += node.x;\n                    if (isNumber(node.y))\n                        c.cy += node.y;\n                });\n                c.cx /= c.count;\n                c.cy /= c.count;\n                return true;\n            });\n        });\n    }\n    applyCalculate(displacements) {\n        const self = this;\n        const comboMap = self.comboMap;\n        const nodes = self.nodes;\n        // store the vx, vy, and distance to reduce dulplicate calculation\n        const vecMap = {};\n        nodes.forEach((v, i) => {\n            nodes.forEach((u, j) => {\n                if (i < j)\n                    return;\n                const vx = (v.x - u.x) || 0.005;\n                const vy = (v.y - u.y) || 0.005;\n                let vl2 = vx * vx + vy * vy;\n                const vl = Math.sqrt(vl2);\n                if (vl2 < 1)\n                    vl2 = vl;\n                vecMap[`${v.id}-${u.id}`] = { vx, vy, vl2, vl };\n                vecMap[`${u.id}-${v.id}`] = { vl2, vl, vx: -vx, vy: -vy };\n            });\n        });\n        // get the sizes of the combos\n        self.updateComboSizes(comboMap);\n        self.calRepulsive(displacements, vecMap);\n        self.calAttractive(displacements, vecMap);\n        const preventComboOverlap = self.preventComboOverlap;\n        if (preventComboOverlap)\n            self.comboNonOverlapping(displacements, comboMap);\n    }\n    /**\n     * Update the sizes of the combos according to their children\n     * Used for combos nonoverlap, but not re-render the combo shapes\n     */\n    updateComboSizes(comboMap) {\n        const self = this;\n        const comboTrees = self.comboTrees;\n        const nodeMap = self.nodeMap;\n        const nodeSize = self.nodeSize;\n        const comboSpacing = self.comboSpacing;\n        const comboPadding = self.comboPadding;\n        (comboTrees || []).forEach((ctree) => {\n            const treeChildren = [];\n            traverseTreeUp(ctree, (treeNode) => {\n                if (treeNode.itemType === \"node\")\n                    return true; // skip it\n                const c = comboMap[treeNode.id];\n                // means the combo is hidden, skip it\n                if (!c)\n                    return false;\n                const children = treeNode.children;\n                if (children) {\n                    children.forEach((child) => {\n                        // means the combo is hidden.\n                        if (!comboMap[child.id] && !nodeMap[child.id])\n                            return;\n                        treeChildren.push(child);\n                    });\n                }\n                c.minX = Infinity;\n                c.minY = Infinity;\n                c.maxX = -Infinity;\n                c.maxY = -Infinity;\n                treeChildren.forEach((child) => {\n                    if (child.itemType !== \"node\")\n                        return true; // skip it\n                    const node = nodeMap[child.id];\n                    if (!node)\n                        return true; // means it is hidden\n                    const r = nodeSize(node);\n                    const nodeMinX = node.x - r;\n                    const nodeMinY = node.y - r;\n                    const nodeMaxX = node.x + r;\n                    const nodeMaxY = node.y + r;\n                    if (c.minX > nodeMinX)\n                        c.minX = nodeMinX;\n                    if (c.minY > nodeMinY)\n                        c.minY = nodeMinY;\n                    if (c.maxX < nodeMaxX)\n                        c.maxX = nodeMaxX;\n                    if (c.maxY < nodeMaxY)\n                        c.maxY = nodeMaxY;\n                });\n                let minSize = self.oriComboMap[treeNode.id].size || 10;\n                if (isArray(minSize))\n                    minSize = minSize[0];\n                const maxLength = Math.max(c.maxX - c.minX, c.maxY - c.minY, minSize);\n                c.r = maxLength / 2 + comboSpacing(c) / 2 + comboPadding(c);\n                return true;\n            });\n        });\n    }\n    /**\n     * prevent the overlappings among combos\n     */\n    comboNonOverlapping(displacements, comboMap) {\n        const self = this;\n        const comboTree = self.comboTree;\n        const comboCollideStrength = self.comboCollideStrength;\n        const indexMap = self.indexMap;\n        const nodeMap = self.nodeMap;\n        traverseTreeUp(comboTree, (treeNode) => {\n            if (!comboMap[treeNode.id] &&\n                !nodeMap[treeNode.id] &&\n                treeNode.id !== \"comboTreeRoot\") {\n                return false;\n            } // means it is hidden\n            const children = treeNode.children;\n            // 同个子树下的子 combo 间两两对比\n            if (children && children.length > 1) {\n                children.forEach((v, i) => {\n                    if (v.itemType === \"node\")\n                        return false; // skip it\n                    const cv = comboMap[v.id];\n                    if (!cv)\n                        return; // means it is hidden, skip it\n                    children.forEach((u, j) => {\n                        if (i <= j)\n                            return false;\n                        if (u.itemType === \"node\")\n                            return false; // skip it\n                        const cu = comboMap[u.id];\n                        if (!cu)\n                            return false; // means it is hidden, skip it\n                        const vx = (cv.cx - cu.cx) || 0.005;\n                        const vy = (cv.cy - cu.cy) || 0.005;\n                        const l = vx * vx + vy * vy;\n                        const rv = cv.r || 1;\n                        const ru = cu.r || 1;\n                        const r = rv + ru;\n                        const ru2 = ru * ru;\n                        const rv2 = rv * rv;\n                        // overlapping\n                        if (l < r * r) {\n                            const vnodes = v.children;\n                            if (!vnodes || vnodes.length === 0)\n                                return false; // skip it\n                            const unodes = u.children;\n                            if (!unodes || unodes.length === 0)\n                                return false; // skip it\n                            const sqrtl = Math.sqrt(l);\n                            const ll = ((r - sqrtl) / sqrtl) * comboCollideStrength;\n                            const xl = vx * ll;\n                            const yl = vy * ll;\n                            const rratio = ru2 / (rv2 + ru2);\n                            const irratio = 1 - rratio;\n                            // 两兄弟 combo 的子节点上施加斥力\n                            vnodes.forEach((vn) => {\n                                if (vn.itemType !== \"node\")\n                                    return false; // skip it\n                                if (!nodeMap[vn.id])\n                                    return; // means it is hidden, skip it\n                                const vindex = indexMap[vn.id];\n                                unodes.forEach((un) => {\n                                    if (un.itemType !== \"node\")\n                                        return false;\n                                    if (!nodeMap[un.id])\n                                        return false; // means it is hidden, skip it\n                                    const uindex = indexMap[un.id];\n                                    displacements[vindex].x += xl * rratio;\n                                    displacements[vindex].y += yl * rratio;\n                                    displacements[uindex].x -= xl * irratio;\n                                    displacements[uindex].y -= yl * irratio;\n                                });\n                            });\n                        }\n                    });\n                });\n            }\n            return true;\n        });\n    }\n    /**\n     * Calculate the repulsive force between each node pair\n     * @param displacements The array stores the displacements for nodes\n     * @param vecMap The map stores vector between each node pair\n     */\n    calRepulsive(displacements, vecMap) {\n        const self = this;\n        const nodes = self.nodes;\n        const max = self.width * self.optimizeRangeFactor;\n        const nodeStrength = self.nodeStrength;\n        const alpha = self.alpha;\n        const nodeCollideStrength = self.nodeCollideStrength;\n        const preventNodeOverlap = self.preventNodeOverlap;\n        const nodeSizeFunc = self.nodeSize;\n        const nodeSpacingFunc = self.nodeSpacing;\n        const scale = self.depthRepulsiveForceScale;\n        const center = self.center;\n        nodes.forEach((v, i) => {\n            if (!v.x || !v.y)\n                return;\n            // center gravity\n            if (center) {\n                const gravity = self.gravity;\n                const vecX = (v.x - center[0]) || 0.005;\n                const vecY = (v.y - center[1]) || 0.005;\n                const l = Math.sqrt(vecX * vecX + vecY * vecY);\n                displacements[i].x -= (vecX * gravity * alpha) / l;\n                displacements[i].y -= (vecY * gravity * alpha) / l;\n            }\n            nodes.forEach((u, j) => {\n                if (i === j) {\n                    return;\n                }\n                if (!u.x || !u.y)\n                    return;\n                const { vl2, vl } = vecMap[`${v.id}-${u.id}`];\n                if (vl > max)\n                    return;\n                const { vx, vy } = vecMap[`${v.id}-${u.id}`];\n                let depthDiff = Math.log(Math.abs(u.depth - v.depth) / 10) + 1 || 1;\n                depthDiff = depthDiff < 1 ? 1 : depthDiff;\n                if (u.comboId !== v.comboId)\n                    depthDiff += 1;\n                const depthParam = depthDiff ? Math.pow(scale, depthDiff) : 1;\n                const params = ((nodeStrength(u) * alpha) / vl2) * depthParam;\n                displacements[i].x += vx * params;\n                displacements[i].y += vy * params;\n                // prevent node overlappings\n                if (i < j && preventNodeOverlap) {\n                    const ri = (nodeSizeFunc(v) + nodeSpacingFunc(v)) || 1;\n                    const rj = (nodeSizeFunc(u) + nodeSpacingFunc(u)) || 1;\n                    const r = ri + rj;\n                    if (vl2 < r * r) {\n                        const ll = ((r - vl) / vl) * nodeCollideStrength;\n                        const rj2 = rj * rj;\n                        let rratio = rj2 / (ri * ri + rj2);\n                        const xl = vx * ll;\n                        const yl = vy * ll;\n                        displacements[i].x += xl * rratio;\n                        displacements[i].y += yl * rratio;\n                        rratio = 1 - rratio;\n                        displacements[j].x -= xl * rratio;\n                        displacements[j].y -= yl * rratio;\n                    }\n                }\n            });\n        });\n    }\n    /**\n     * Calculate the attractive force between the node pair with edge\n     * @param displacements The array stores the displacements for nodes\n     * @param vecMap The map stores vector between each node pair\n     */\n    calAttractive(displacements, vecMap) {\n        const self = this;\n        const edges = self.edges;\n        const linkDistance = self.linkDistance;\n        const alpha = self.alpha;\n        const edgeStrength = self.edgeStrength;\n        const bias = self.bias;\n        const scale = self.depthAttractiveForceScale;\n        edges.forEach((e, i) => {\n            const source = getEdgeTerminal(e, 'source');\n            const target = getEdgeTerminal(e, 'target');\n            if (!source || !target || source === target)\n                return;\n            const uIndex = self.indexMap[source];\n            const vIndex = self.indexMap[target];\n            const u = self.nodeMap[source];\n            const v = self.nodeMap[target];\n            if (!u || !v)\n                return;\n            let depthDiff = u.depth === v.depth ? 0 : Math.log(Math.abs(u.depth - v.depth) / 10);\n            if (u.comboId === v.comboId) {\n                depthDiff = depthDiff / 2;\n            }\n            let depthParam = depthDiff ? Math.pow(scale, depthDiff) : 1;\n            if (u.comboId !== v.comboId && depthParam === 1) {\n                depthParam = scale / 2;\n            }\n            else if (u.comboId === v.comboId) {\n                depthParam = 2;\n            }\n            if (!isNumber(v.x) || !isNumber(u.x) || !isNumber(v.y) || !isNumber(u.y)) {\n                return;\n            }\n            const { vl, vx, vy } = vecMap[`${target}-${source}`];\n            const l = ((vl - linkDistance(e)) / vl) * alpha * edgeStrength(e) * depthParam;\n            const vecX = vx * l;\n            const vecY = vy * l;\n            const b = bias[i];\n            displacements[vIndex].x -= vecX * b;\n            displacements[vIndex].y -= vecY * b;\n            displacements[uIndex].x += vecX * (1 - b);\n            displacements[uIndex].y += vecY * (1 - b);\n        });\n    }\n    getType() {\n        return \"comboForce\";\n    }\n}\n//# sourceMappingURL=comboForce.js.map"]},"metadata":{},"sourceType":"module"}