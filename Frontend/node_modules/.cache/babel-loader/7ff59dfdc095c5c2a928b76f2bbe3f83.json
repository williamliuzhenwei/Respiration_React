{"ast":null,"code":"import _classCallCheck from \"/Users/liuzhenwei/Desktop/Respiration_React/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/liuzhenwei/Desktop/Respiration_React/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { Matrix as MLMatrix, SingularValueDecomposition } from 'ml-matrix';\n\nvar MDS = /*#__PURE__*/function () {\n  function MDS(params) {\n    _classCallCheck(this, MDS);\n\n    this.distances = params.distances;\n    this.dimension = params.dimension || 2;\n    this.linkDistance = params.linkDistance;\n  }\n\n  _createClass(MDS, [{\n    key: \"layout\",\n    value: function layout() {\n      var self = this;\n      var dimension = self.dimension,\n          distances = self.distances,\n          linkDistance = self.linkDistance;\n\n      try {\n        // square distances\n        var M = MLMatrix.mul(MLMatrix.pow(distances, 2), -0.5); // double centre the rows/columns\n\n        var rowMeans = M.mean('row');\n        var colMeans = M.mean('column');\n        var totalMean = M.mean();\n        M.add(totalMean).subRowVector(rowMeans).subColumnVector(colMeans); // take the SVD of the double centred matrix, and return the\n        // points from it\n\n        var ret = new SingularValueDecomposition(M);\n        var eigenValues = MLMatrix.sqrt(ret.diagonalMatrix).diagonal();\n        return ret.leftSingularVectors.toJSON().map(function (row) {\n          return MLMatrix.mul([row], [eigenValues]).toJSON()[0].splice(0, dimension);\n        });\n      } catch (_a) {\n        var res = [];\n\n        for (var i = 0; i < distances.length; i++) {\n          var x = Math.random() * linkDistance;\n          var y = Math.random() * linkDistance;\n          res.push([x, y]);\n        }\n\n        return res;\n      }\n    }\n  }]);\n\n  return MDS;\n}();\n\nexport { MDS as default };","map":{"version":3,"sources":["../../../src/layout/radial/mds.ts"],"names":[],"mappings":";;AACA,SAAS,MAAM,IAAI,QAAnB,EAA6B,0BAA7B,QAA+D,WAA/D;;IAEqB,G;AAUnB,eAAY,MAAZ,EAAqF;AAAA;;AACnF,SAAK,SAAL,GAAiB,MAAM,CAAC,SAAxB;AACA,SAAK,SAAL,GAAiB,MAAM,CAAC,SAAP,IAAoB,CAArC;AACA,SAAK,YAAL,GAAoB,MAAM,CAAC,YAA3B;AACD;;;;WAEM,kBAAM;AACX,UAAM,IAAI,GAAG,IAAb;AACA,UAAQ,SAAR,GAA+C,IAA/C,CAAQ,SAAR;AAAA,UAAmB,SAAnB,GAA+C,IAA/C,CAAmB,SAAnB;AAAA,UAA8B,YAA9B,GAA+C,IAA/C,CAA8B,YAA9B;;AAEA,UAAI;AACF;AACA,YAAM,CAAC,GAAG,QAAQ,CAAC,GAAT,CAAa,QAAQ,CAAC,GAAT,CAAa,SAAb,EAAwB,CAAxB,CAAb,EAAyC,CAAC,GAA1C,CAAV,CAFE,CAIF;;AACA,YAAM,QAAQ,GAAG,CAAC,CAAC,IAAF,CAAO,KAAP,CAAjB;AACA,YAAM,QAAQ,GAAG,CAAC,CAAC,IAAF,CAAO,QAAP,CAAjB;AACA,YAAM,SAAS,GAAG,CAAC,CAAC,IAAF,EAAlB;AACA,QAAA,CAAC,CAAC,GAAF,CAAM,SAAN,EAAiB,YAAjB,CAA8B,QAA9B,EAAwC,eAAxC,CAAwD,QAAxD,EARE,CAUF;AACA;;AACA,YAAM,GAAG,GAAG,IAAI,0BAAJ,CAA+B,CAA/B,CAAZ;AACA,YAAM,WAAW,GAAG,QAAQ,CAAC,IAAT,CAAc,GAAG,CAAC,cAAlB,EAAkC,QAAlC,EAApB;AACA,eAAO,GAAG,CAAC,mBAAJ,CAAwB,MAAxB,GAAiC,GAAjC,CAAqC,UAAC,GAAD,EAAkB;AAC5D,iBAAO,QAAQ,CAAC,GAAT,CAAa,CAAC,GAAD,CAAb,EAAoB,CAAC,WAAD,CAApB,EAAmC,MAAnC,GAA4C,CAA5C,EAA+C,MAA/C,CAAsD,CAAtD,EAAyD,SAAzD,CAAP;AACD,SAFM,CAAP;AAGD,OAjBD,CAiBE,OAAA,EAAA,EAAM;AACN,YAAM,GAAG,GAAiB,EAA1B;;AACA,aAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,SAAS,CAAC,MAA9B,EAAsC,CAAC,EAAvC,EAA2C;AACzC,cAAM,CAAC,GAAG,IAAI,CAAC,MAAL,KAAgB,YAA1B;AACA,cAAM,CAAC,GAAG,IAAI,CAAC,MAAL,KAAgB,YAA1B;AACA,UAAA,GAAG,CAAC,IAAJ,CAAS,CAAC,CAAD,EAAI,CAAJ,CAAT;AACD;;AACD,eAAO,GAAP;AACD;AACF;;;;;;SA9CkB,G","sourceRoot":"","sourcesContent":["import { Matrix as MLMatrix, SingularValueDecomposition } from 'ml-matrix';\nexport default class MDS {\n    constructor(params) {\n        this.distances = params.distances;\n        this.dimension = params.dimension || 2;\n        this.linkDistance = params.linkDistance;\n    }\n    layout() {\n        const self = this;\n        const { dimension, distances, linkDistance } = self;\n        try {\n            // square distances\n            const M = MLMatrix.mul(MLMatrix.pow(distances, 2), -0.5);\n            // double centre the rows/columns\n            const rowMeans = M.mean('row');\n            const colMeans = M.mean('column');\n            const totalMean = M.mean();\n            M.add(totalMean).subRowVector(rowMeans).subColumnVector(colMeans);\n            // take the SVD of the double centred matrix, and return the\n            // points from it\n            const ret = new SingularValueDecomposition(M);\n            const eigenValues = MLMatrix.sqrt(ret.diagonalMatrix).diagonal();\n            return ret.leftSingularVectors.toJSON().map((row) => {\n                return MLMatrix.mul([row], [eigenValues]).toJSON()[0].splice(0, dimension);\n            });\n        }\n        catch (_a) {\n            const res = [];\n            for (let i = 0; i < distances.length; i++) {\n                const x = Math.random() * linkDistance;\n                const y = Math.random() * linkDistance;\n                res.push([x, y]);\n            }\n            return res;\n        }\n    }\n}\n//# sourceMappingURL=mds.js.map"]},"metadata":{},"sourceType":"module"}