{"ast":null,"code":"import _classCallCheck from \"/Users/liuzhenwei/Desktop/Respiration_React/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/liuzhenwei/Desktop/Respiration_React/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/liuzhenwei/Desktop/Respiration_React/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/liuzhenwei/Desktop/Respiration_React/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/**\n * @fileOverview concentric layout\n * @author shiwu.wyy@antfin.com\n * this algorithm refers to <cytoscape.js> - https://github.com/cytoscape/cytoscape.js/\n */\nimport { isString, isArray, isNumber, getDegree, isObject } from \"../util\";\nimport { Base } from \"./base\";\n/**\n * 同心圆布局\n */\n\nexport var ConcentricLayout = /*#__PURE__*/function (_Base) {\n  _inherits(ConcentricLayout, _Base);\n\n  var _super = _createSuper(ConcentricLayout);\n\n  function ConcentricLayout(options) {\n    var _this;\n\n    _classCallCheck(this, ConcentricLayout);\n\n    _this = _super.call(this);\n    _this.nodeSize = 30;\n    /** min spacing between outside of nodes (used for radius adjustment) */\n\n    _this.minNodeSpacing = 10;\n    /** prevents node overlap, may overflow boundingBox if not enough space */\n\n    _this.preventOverlap = false;\n    /** whether levels have an equal radial distance betwen them, may cause bounding box overflow */\n\n    _this.equidistant = false;\n    /** where nodes start in radians */\n\n    _this.startAngle = 3 / 2 * Math.PI;\n    /** whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false) */\n\n    _this.clockwise = true;\n    /** 根据 sortBy 指定的属性进行排布，数值高的放在中心，如果是 sortBy 则会计算节点度数，度数最高的放在中心 */\n\n    _this.sortBy = \"degree\";\n    _this.nodes = [];\n    _this.edges = [];\n    _this.width = 300;\n    _this.height = 300;\n    /** 迭代结束的回调函数 */\n\n    _this.onLayoutEnd = function () {};\n\n    _this.updateCfg(options);\n\n    return _this;\n  }\n\n  _createClass(ConcentricLayout, [{\n    key: \"getDefaultCfg\",\n    value: function getDefaultCfg() {\n      return {\n        nodeSize: 30,\n        minNodeSpacing: 10,\n        preventOverlap: false,\n        sweep: undefined,\n        equidistant: false,\n        startAngle: 3 / 2 * Math.PI,\n        clockwise: true,\n        maxLevelDiff: undefined,\n        sortBy: \"degree\"\n      };\n    }\n    /**\n     * 执行布局\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute() {\n      var self = this;\n      var nodes = self.nodes;\n      var edges = self.edges;\n      var n = nodes.length;\n\n      if (n === 0) {\n        if (self.onLayoutEnd) self.onLayoutEnd();\n        return;\n      }\n\n      if (!self.width && typeof window !== \"undefined\") {\n        self.width = window.innerWidth;\n      }\n\n      if (!self.height && typeof window !== \"undefined\") {\n        self.height = window.innerHeight;\n      }\n\n      if (!self.center) {\n        self.center = [self.width / 2, self.height / 2];\n      }\n\n      var center = self.center;\n\n      if (n === 1) {\n        nodes[0].x = center[0];\n        nodes[0].y = center[1];\n        if (self.onLayoutEnd) self.onLayoutEnd();\n        return;\n      }\n\n      var layoutNodes = [];\n      var maxNodeSize;\n\n      if (isArray(self.nodeSize)) {\n        maxNodeSize = Math.max(self.nodeSize[0], self.nodeSize[1]);\n      } else {\n        maxNodeSize = self.nodeSize;\n      }\n\n      nodes.forEach(function (node) {\n        layoutNodes.push(node);\n        var nodeSize = maxNodeSize;\n\n        if (isArray(node.size)) {\n          nodeSize = Math.max(node.size[0], node.size[1]);\n        } else if (isNumber(node.size)) {\n          nodeSize = node.size;\n        } else if (isObject(node.size)) {\n          nodeSize = Math.max(node.size.width, node.size.height);\n        }\n\n        maxNodeSize = Math.max(maxNodeSize, nodeSize);\n      });\n      self.clockwise = self.counterclockwise !== undefined ? !self.counterclockwise : self.clockwise; // layout\n\n      var nodeMap = {};\n      var indexMap = {};\n      layoutNodes.forEach(function (node, i) {\n        nodeMap[node.id] = node;\n        indexMap[node.id] = i;\n      }); // get the node degrees\n\n      if (self.sortBy === \"degree\" || !isString(self.sortBy) || layoutNodes[0][self.sortBy] === undefined) {\n        self.sortBy = \"degree\";\n\n        if (!isNumber(nodes[0].degree)) {\n          var values = getDegree(nodes.length, indexMap, edges);\n          layoutNodes.forEach(function (node, i) {\n            node.degree = values[i];\n          });\n        }\n      } // sort nodes by value\n\n\n      layoutNodes.sort(function (n1, n2) {\n        return n2[self.sortBy] - n1[self.sortBy];\n      });\n      self.maxValueNode = layoutNodes[0];\n      self.maxLevelDiff = self.maxLevelDiff || self.maxValueNode[self.sortBy] / 4; // put the values into levels\n\n      var levels = [[]];\n      var currentLevel = levels[0];\n      layoutNodes.forEach(function (node) {\n        if (currentLevel.length > 0) {\n          var diff = Math.abs(currentLevel[0][self.sortBy] - node[self.sortBy]);\n\n          if (self.maxLevelDiff && diff >= self.maxLevelDiff) {\n            currentLevel = [];\n            levels.push(currentLevel);\n          }\n        }\n\n        currentLevel.push(node);\n      }); // create positions for levels\n\n      var minDist = maxNodeSize + self.minNodeSpacing; // min dist between nodes\n\n      if (!self.preventOverlap) {\n        // then strictly constrain to bb\n        var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;\n        var maxR = Math.min(self.width, self.height) / 2 - minDist;\n        var rStep = maxR / (levels.length + (firstLvlHasMulti ? 1 : 0));\n        minDist = Math.min(minDist, rStep);\n      } // find the metrics for each level\n\n\n      var r = 0;\n      levels.forEach(function (level) {\n        var sweep = self.sweep;\n\n        if (sweep === undefined) {\n          sweep = 2 * Math.PI - 2 * Math.PI / level.length;\n        }\n\n        var dTheta = level.dTheta = sweep / Math.max(1, level.length - 1); // calculate the radius\n\n        if (level.length > 1 && self.preventOverlap) {\n          // but only if more than one node (can't overlap)\n          var dcos = Math.cos(dTheta) - Math.cos(0);\n          var dsin = Math.sin(dTheta) - Math.sin(0);\n          var rMin = Math.sqrt(minDist * minDist / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping\n\n          r = Math.max(rMin, r);\n        }\n\n        level.r = r;\n        r += minDist;\n      });\n\n      if (self.equidistant) {\n        var rDeltaMax = 0;\n        var rr = 0;\n\n        for (var i = 0; i < levels.length; i++) {\n          var level = levels[i];\n          var rDelta = level.r - rr;\n          rDeltaMax = Math.max(rDeltaMax, rDelta);\n        }\n\n        rr = 0;\n        levels.forEach(function (level, i) {\n          if (i === 0) {\n            rr = level.r;\n          }\n\n          level.r = rr;\n          rr += rDeltaMax;\n        });\n      } // calculate the node positions\n\n\n      levels.forEach(function (level) {\n        var dTheta = level.dTheta;\n        var rr = level.r;\n        level.forEach(function (node, j) {\n          var theta = self.startAngle + (self.clockwise ? 1 : -1) * dTheta * j;\n          node.x = center[0] + rr * Math.cos(theta);\n          node.y = center[1] + rr * Math.sin(theta);\n        });\n      });\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return {\n        nodes: nodes,\n        edges: edges\n      };\n    }\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      return \"concentric\";\n    }\n  }]);\n\n  return ConcentricLayout;\n}(Base);","map":{"version":3,"sources":["../../src/layout/concentric.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @fileOverview concentric layout\n * @author shiwu.wyy@antfin.com\n * this algorithm refers to <cytoscape.js> - https://github.com/cytoscape/cytoscape.js/\n */\nimport { isString, isArray, isNumber, getDegree, isObject } from \"../util\";\nimport { Base } from \"./base\";\n/**\n * 同心圆布局\n */\nexport class ConcentricLayout extends Base {\n    constructor(options) {\n        super();\n        this.nodeSize = 30;\n        /** min spacing between outside of nodes (used for radius adjustment) */\n        this.minNodeSpacing = 10;\n        /** prevents node overlap, may overflow boundingBox if not enough space */\n        this.preventOverlap = false;\n        /** whether levels have an equal radial distance betwen them, may cause bounding box overflow */\n        this.equidistant = false;\n        /** where nodes start in radians */\n        this.startAngle = (3 / 2) * Math.PI;\n        /** whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false) */\n        this.clockwise = true;\n        /** 根据 sortBy 指定的属性进行排布，数值高的放在中心，如果是 sortBy 则会计算节点度数，度数最高的放在中心 */\n        this.sortBy = \"degree\";\n        this.nodes = [];\n        this.edges = [];\n        this.width = 300;\n        this.height = 300;\n        /** 迭代结束的回调函数 */\n        this.onLayoutEnd = () => { };\n        this.updateCfg(options);\n    }\n    getDefaultCfg() {\n        return {\n            nodeSize: 30,\n            minNodeSpacing: 10,\n            preventOverlap: false,\n            sweep: undefined,\n            equidistant: false,\n            startAngle: (3 / 2) * Math.PI,\n            clockwise: true,\n            maxLevelDiff: undefined,\n            sortBy: \"degree\"\n        };\n    }\n    /**\n     * 执行布局\n     */\n    execute() {\n        const self = this;\n        const nodes = self.nodes;\n        const edges = self.edges;\n        const n = nodes.length;\n        if (n === 0) {\n            if (self.onLayoutEnd)\n                self.onLayoutEnd();\n            return;\n        }\n        if (!self.width && typeof window !== \"undefined\") {\n            self.width = window.innerWidth;\n        }\n        if (!self.height && typeof window !== \"undefined\") {\n            self.height = window.innerHeight;\n        }\n        if (!self.center) {\n            self.center = [self.width / 2, self.height / 2];\n        }\n        const center = self.center;\n        if (n === 1) {\n            nodes[0].x = center[0];\n            nodes[0].y = center[1];\n            if (self.onLayoutEnd)\n                self.onLayoutEnd();\n            return;\n        }\n        const layoutNodes = [];\n        let maxNodeSize;\n        if (isArray(self.nodeSize)) {\n            maxNodeSize = Math.max(self.nodeSize[0], self.nodeSize[1]);\n        }\n        else {\n            maxNodeSize = self.nodeSize;\n        }\n        nodes.forEach((node) => {\n            layoutNodes.push(node);\n            let nodeSize = maxNodeSize;\n            if (isArray(node.size)) {\n                nodeSize = Math.max(node.size[0], node.size[1]);\n            }\n            else if (isNumber(node.size)) {\n                nodeSize = node.size;\n            }\n            else if (isObject(node.size)) {\n                nodeSize = Math.max(node.size.width, node.size.height);\n            }\n            maxNodeSize = Math.max(maxNodeSize, nodeSize);\n        });\n        self.clockwise =\n            self.counterclockwise !== undefined\n                ? !self.counterclockwise\n                : self.clockwise;\n        // layout\n        const nodeMap = {};\n        const indexMap = {};\n        layoutNodes.forEach((node, i) => {\n            nodeMap[node.id] = node;\n            indexMap[node.id] = i;\n        });\n        // get the node degrees\n        if (self.sortBy === \"degree\" ||\n            !isString(self.sortBy) ||\n            layoutNodes[0][self.sortBy] === undefined) {\n            self.sortBy = \"degree\";\n            if (!isNumber(nodes[0].degree)) {\n                const values = getDegree(nodes.length, indexMap, edges);\n                layoutNodes.forEach((node, i) => {\n                    node.degree = values[i];\n                });\n            }\n        }\n        // sort nodes by value\n        layoutNodes.sort((n1, n2) => n2[self.sortBy] - n1[self.sortBy]);\n        self.maxValueNode = layoutNodes[0];\n        self.maxLevelDiff =\n            self.maxLevelDiff || self.maxValueNode[self.sortBy] / 4;\n        // put the values into levels\n        const levels = [[]];\n        let currentLevel = levels[0];\n        layoutNodes.forEach((node) => {\n            if (currentLevel.length > 0) {\n                const diff = Math.abs(currentLevel[0][self.sortBy] - node[self.sortBy]);\n                if (self.maxLevelDiff && diff >= self.maxLevelDiff) {\n                    currentLevel = [];\n                    levels.push(currentLevel);\n                }\n            }\n            currentLevel.push(node);\n        });\n        // create positions for levels\n        let minDist = maxNodeSize + self.minNodeSpacing; // min dist between nodes\n        if (!self.preventOverlap) {\n            // then strictly constrain to bb\n            const firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;\n            const maxR = Math.min(self.width, self.height) / 2 - minDist;\n            const rStep = maxR / (levels.length + (firstLvlHasMulti ? 1 : 0));\n            minDist = Math.min(minDist, rStep);\n        }\n        // find the metrics for each level\n        let r = 0;\n        levels.forEach((level) => {\n            let sweep = self.sweep;\n            if (sweep === undefined) {\n                sweep = 2 * Math.PI - (2 * Math.PI) / level.length;\n            }\n            const dTheta = (level.dTheta = sweep / Math.max(1, level.length - 1));\n            // calculate the radius\n            if (level.length > 1 && self.preventOverlap) {\n                // but only if more than one node (can't overlap)\n                const dcos = Math.cos(dTheta) - Math.cos(0);\n                const dsin = Math.sin(dTheta) - Math.sin(0);\n                const rMin = Math.sqrt((minDist * minDist) / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping\n                r = Math.max(rMin, r);\n            }\n            level.r = r;\n            r += minDist;\n        });\n        if (self.equidistant) {\n            let rDeltaMax = 0;\n            let rr = 0;\n            for (let i = 0; i < levels.length; i++) {\n                const level = levels[i];\n                const rDelta = level.r - rr;\n                rDeltaMax = Math.max(rDeltaMax, rDelta);\n            }\n            rr = 0;\n            levels.forEach((level, i) => {\n                if (i === 0) {\n                    rr = level.r;\n                }\n                level.r = rr;\n                rr += rDeltaMax;\n            });\n        }\n        // calculate the node positions\n        levels.forEach((level) => {\n            const dTheta = level.dTheta;\n            const rr = level.r;\n            level.forEach((node, j) => {\n                const theta = self.startAngle + (self.clockwise ? 1 : -1) * dTheta * j;\n                node.x = center[0] + rr * Math.cos(theta);\n                node.y = center[1] + rr * Math.sin(theta);\n            });\n        });\n        if (self.onLayoutEnd)\n            self.onLayoutEnd();\n        return {\n            nodes,\n            edges\n        };\n    }\n    getType() {\n        return \"concentric\";\n    }\n}\n//# sourceMappingURL=concentric.js.map"]},"metadata":{},"sourceType":"module"}