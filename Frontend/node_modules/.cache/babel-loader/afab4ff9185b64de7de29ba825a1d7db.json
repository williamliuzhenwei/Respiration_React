{"ast":null,"code":"import _classCallCheck from \"/Users/liuzhenwei/Desktop/Respiration_React/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/liuzhenwei/Desktop/Respiration_React/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/liuzhenwei/Desktop/Respiration_React/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/liuzhenwei/Desktop/Respiration_React/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/**\n * @fileOverview MDS layout\n * @author shiwu.wyy@antfin.com\n */\nimport { Matrix as MLMatrix, SingularValueDecomposition } from \"ml-matrix\";\nimport { floydWarshall, getAdjMatrix, scaleMatrix } from \"../util\";\nimport { Base } from \"./base\";\n/**\n * mds 布局\n */\n\nexport var MDSLayout = /*#__PURE__*/function (_Base) {\n  _inherits(MDSLayout, _Base);\n\n  var _super = _createSuper(MDSLayout);\n\n  function MDSLayout(options) {\n    var _this;\n\n    _classCallCheck(this, MDSLayout);\n\n    _this = _super.call(this);\n    /** 布局中心 */\n\n    _this.center = [0, 0];\n    /** 边长度 */\n\n    _this.linkDistance = 50;\n    _this.nodes = [];\n    _this.edges = [];\n    /** 迭代结束的回调函数 */\n\n    _this.onLayoutEnd = function () {};\n\n    _this.updateCfg(options);\n\n    return _this;\n  }\n\n  _createClass(MDSLayout, [{\n    key: \"getDefaultCfg\",\n    value: function getDefaultCfg() {\n      return {\n        center: [0, 0],\n        linkDistance: 50\n      };\n    }\n    /**\n     * 执行布局\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute() {\n      var self = this;\n      var nodes = self.nodes,\n          _self$edges = self.edges,\n          edges = _self$edges === void 0 ? [] : _self$edges;\n      var center = self.center;\n\n      if (!nodes || nodes.length === 0) {\n        if (self.onLayoutEnd) self.onLayoutEnd();\n        return;\n      }\n\n      if (nodes.length === 1) {\n        nodes[0].x = center[0];\n        nodes[0].y = center[1];\n        if (self.onLayoutEnd) self.onLayoutEnd();\n        return;\n      }\n\n      var linkDistance = self.linkDistance; // the graph-theoretic distance (shortest path distance) matrix\n\n      var adjMatrix = getAdjMatrix({\n        nodes: nodes,\n        edges: edges\n      }, false);\n      var distances = floydWarshall(adjMatrix);\n      self.handleInfinity(distances); // scale the ideal edge length acoording to linkDistance\n\n      var scaledD = scaleMatrix(distances, linkDistance);\n      self.scaledDistances = scaledD; // get positions by MDS\n\n      var positions = self.runMDS();\n      self.positions = positions;\n      positions.forEach(function (p, i) {\n        nodes[i].x = p[0] + center[0];\n        nodes[i].y = p[1] + center[1];\n      });\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return {\n        nodes: nodes,\n        edges: edges\n      };\n    }\n    /**\n     * mds 算法\n     * @return {array} positions 计算后的节点位置数组\n     */\n\n  }, {\n    key: \"runMDS\",\n    value: function runMDS() {\n      var self = this;\n      var dimension = 2;\n      var distances = self.scaledDistances; // square distances\n\n      var M = MLMatrix.mul(MLMatrix.pow(distances, 2), -0.5); // double centre the rows/columns\n\n      var rowMeans = M.mean(\"row\");\n      var colMeans = M.mean(\"column\");\n      var totalMean = M.mean();\n      M.add(totalMean).subRowVector(rowMeans).subColumnVector(colMeans); // take the SVD of the double centred matrix, and return the\n      // points from it\n\n      var ret = new SingularValueDecomposition(M);\n      var eigenValues = MLMatrix.sqrt(ret.diagonalMatrix).diagonal();\n      return ret.leftSingularVectors.toJSON().map(function (row) {\n        return MLMatrix.mul([row], [eigenValues]).toJSON()[0].splice(0, dimension);\n      });\n    }\n  }, {\n    key: \"handleInfinity\",\n    value: function handleInfinity(distances) {\n      var maxDistance = -999999;\n      distances.forEach(function (row) {\n        row.forEach(function (value) {\n          if (value === Infinity) {\n            return;\n          }\n\n          if (maxDistance < value) {\n            maxDistance = value;\n          }\n        });\n      });\n      distances.forEach(function (row, i) {\n        row.forEach(function (value, j) {\n          if (value === Infinity) {\n            distances[i][j] = maxDistance;\n          }\n        });\n      });\n    }\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      return \"mds\";\n    }\n  }]);\n\n  return MDSLayout;\n}(Base);","map":{"version":3,"sources":["../../src/layout/mds.ts"],"names":[],"mappings":";;;;;AAAA;;;AAGG;AAEH,SAAS,MAAM,IAAI,QAAnB,EAA6B,0BAA7B,QAA+D,WAA/D;AAEA,SAAS,aAAT,EAAwB,YAAxB,EAAsC,WAAtC,QAAyD,SAAzD;AACA,SAAS,IAAT,QAAqB,QAArB;AAEA;;AAEG;;AACH,WAAa,SAAb;AAAA;;AAAA;;AAgBE,qBAAY,OAAZ,EAAsC;AAAA;;AAAA;;AACpC;AAhBF;;AACO,UAAA,MAAA,GAAqB,CAAC,CAAD,EAAI,CAAJ,CAArB;AAEP;;AACO,UAAA,YAAA,GAAuB,EAAvB;AAIA,UAAA,KAAA,GAAmB,EAAnB;AAEA,UAAA,KAAA,GAAgB,EAAhB;AAEP;;AACO,UAAA,WAAA,GAA0B,YAAK,CAAG,CAAlC;;AAIL,UAAK,SAAL,CAAe,OAAf;;AAFoC;AAGrC;;AAnBH;AAAA;AAAA,WAqBS,yBAAa;AAClB,aAAO;AACL,QAAA,MAAM,EAAE,CAAC,CAAD,EAAI,CAAJ,CADH;AAEL,QAAA,YAAY,EAAE;AAFT,OAAP;AAID;AAED;;AAEG;;AA9BL;AAAA;AAAA,WA+BS,mBAAO;AACZ,UAAM,IAAI,GAAG,IAAb;AACA,UAAQ,KAAR,GAA8B,IAA9B,CAAQ,KAAR;AAAA,wBAA8B,IAA9B,CAAe,KAAf;AAAA,UAAe,KAAf,4BAAuB,EAAvB;AACA,UAAM,MAAM,GAAG,IAAI,CAAC,MAApB;;AACA,UAAI,CAAC,KAAD,IAAU,KAAK,CAAC,MAAN,KAAiB,CAA/B,EAAkC;AAChC,YAAI,IAAI,CAAC,WAAT,EAAsB,IAAI,CAAC,WAAL;AACtB;AACD;;AACD,UAAI,KAAK,CAAC,MAAN,KAAiB,CAArB,EAAwB;AACtB,QAAA,KAAK,CAAC,CAAD,CAAL,CAAS,CAAT,GAAa,MAAM,CAAC,CAAD,CAAnB;AACA,QAAA,KAAK,CAAC,CAAD,CAAL,CAAS,CAAT,GAAa,MAAM,CAAC,CAAD,CAAnB;AACA,YAAI,IAAI,CAAC,WAAT,EAAsB,IAAI,CAAC,WAAL;AACtB;AACD;;AACD,UAAM,YAAY,GAAG,IAAI,CAAC,YAA1B,CAdY,CAeZ;;AACA,UAAM,SAAS,GAAG,YAAY,CAAC;AAAE,QAAA,KAAK,EAAL,KAAF;AAAS,QAAA,KAAK,EAAL;AAAT,OAAD,EAAmB,KAAnB,CAA9B;AACA,UAAM,SAAS,GAAG,aAAa,CAAC,SAAD,CAA/B;AACA,MAAA,IAAI,CAAC,cAAL,CAAoB,SAApB,EAlBY,CAoBZ;;AACA,UAAM,OAAO,GAAG,WAAW,CAAC,SAAD,EAAY,YAAZ,CAA3B;AACA,MAAA,IAAI,CAAC,eAAL,GAAuB,OAAvB,CAtBY,CAwBZ;;AACA,UAAM,SAAS,GAAG,IAAI,CAAC,MAAL,EAAlB;AACA,MAAA,IAAI,CAAC,SAAL,GAAiB,SAAjB;AACA,MAAA,SAAS,CAAC,OAAV,CAAkB,UAAC,CAAD,EAAc,CAAd,EAA2B;AAC3C,QAAA,KAAK,CAAC,CAAD,CAAL,CAAS,CAAT,GAAa,CAAC,CAAC,CAAD,CAAD,GAAO,MAAM,CAAC,CAAD,CAA1B;AACA,QAAA,KAAK,CAAC,CAAD,CAAL,CAAS,CAAT,GAAa,CAAC,CAAC,CAAD,CAAD,GAAO,MAAM,CAAC,CAAD,CAA1B;AACD,OAHD;AAKA,UAAI,IAAI,CAAC,WAAT,EAAsB,IAAI,CAAC,WAAL;AAEtB,aAAO;AACL,QAAA,KAAK,EAAL,KADK;AAEL,QAAA,KAAK,EAAL;AAFK,OAAP;AAID;AAED;;;AAGG;;AA1EL;AAAA;AAAA,WA2ES,kBAAM;AACX,UAAM,IAAI,GAAG,IAAb;AACA,UAAM,SAAS,GAAG,CAAlB;AACA,UAAM,SAAS,GAAG,IAAI,CAAC,eAAvB,CAHW,CAKX;;AACA,UAAM,CAAC,GAAG,QAAQ,CAAC,GAAT,CAAa,QAAQ,CAAC,GAAT,CAAa,SAAb,EAAwB,CAAxB,CAAb,EAAyC,CAAC,GAA1C,CAAV,CANW,CAQX;;AACA,UAAM,QAAQ,GAAG,CAAC,CAAC,IAAF,CAAO,KAAP,CAAjB;AACA,UAAM,QAAQ,GAAG,CAAC,CAAC,IAAF,CAAO,QAAP,CAAjB;AACA,UAAM,SAAS,GAAG,CAAC,CAAC,IAAF,EAAlB;AACA,MAAA,CAAC,CAAC,GAAF,CAAM,SAAN,EACG,YADH,CACgB,QADhB,EAEG,eAFH,CAEmB,QAFnB,EAZW,CAgBX;AACA;;AACA,UAAM,GAAG,GAAG,IAAI,0BAAJ,CAA+B,CAA/B,CAAZ;AACA,UAAM,WAAW,GAAG,QAAQ,CAAC,IAAT,CAAc,GAAG,CAAC,cAAlB,EAAkC,QAAlC,EAApB;AACA,aAAO,GAAG,CAAC,mBAAJ,CAAwB,MAAxB,GAAiC,GAAjC,CAAqC,UAAC,GAAD,EAAkB;AAC5D,eAAO,QAAQ,CAAC,GAAT,CAAa,CAAC,GAAD,CAAb,EAAoB,CAAC,WAAD,CAApB,EACJ,MADI,GACK,CADL,EAEJ,MAFI,CAEG,CAFH,EAEM,SAFN,CAAP;AAGD,OAJM,CAAP;AAKD;AApGH;AAAA;AAAA,WAsGS,wBAAe,SAAf,EAAkC;AACvC,UAAI,WAAW,GAAG,CAAC,MAAnB;AACA,MAAA,SAAS,CAAC,OAAV,CAAkB,UAAC,GAAD,EAAQ;AACxB,QAAA,GAAG,CAAC,OAAJ,CAAY,UAAC,KAAD,EAAU;AACpB,cAAI,KAAK,KAAK,QAAd,EAAwB;AACtB;AACD;;AACD,cAAI,WAAW,GAAG,KAAlB,EAAyB;AACvB,YAAA,WAAW,GAAG,KAAd;AACD;AACF,SAPD;AAQD,OATD;AAUA,MAAA,SAAS,CAAC,OAAV,CAAkB,UAAC,GAAD,EAAM,CAAN,EAAW;AAC3B,QAAA,GAAG,CAAC,OAAJ,CAAY,UAAC,KAAD,EAAQ,CAAR,EAAa;AACvB,cAAI,KAAK,KAAK,QAAd,EAAwB;AACtB,YAAA,SAAS,CAAC,CAAD,CAAT,CAAa,CAAb,IAAkB,WAAlB;AACD;AACF,SAJD;AAKD,OAND;AAOD;AAzHH;AAAA;AAAA,WA2HS,mBAAO;AACZ,aAAO,KAAP;AACD;AA7HH;;AAAA;AAAA,EAA+B,IAA/B","sourceRoot":"","sourcesContent":["/**\n * @fileOverview MDS layout\n * @author shiwu.wyy@antfin.com\n */\nimport { Matrix as MLMatrix, SingularValueDecomposition } from \"ml-matrix\";\nimport { floydWarshall, getAdjMatrix, scaleMatrix } from \"../util\";\nimport { Base } from \"./base\";\n/**\n * mds 布局\n */\nexport class MDSLayout extends Base {\n    constructor(options) {\n        super();\n        /** 布局中心 */\n        this.center = [0, 0];\n        /** 边长度 */\n        this.linkDistance = 50;\n        this.nodes = [];\n        this.edges = [];\n        /** 迭代结束的回调函数 */\n        this.onLayoutEnd = () => { };\n        this.updateCfg(options);\n    }\n    getDefaultCfg() {\n        return {\n            center: [0, 0],\n            linkDistance: 50\n        };\n    }\n    /**\n     * 执行布局\n     */\n    execute() {\n        const self = this;\n        const { nodes, edges = [] } = self;\n        const center = self.center;\n        if (!nodes || nodes.length === 0) {\n            if (self.onLayoutEnd)\n                self.onLayoutEnd();\n            return;\n        }\n        if (nodes.length === 1) {\n            nodes[0].x = center[0];\n            nodes[0].y = center[1];\n            if (self.onLayoutEnd)\n                self.onLayoutEnd();\n            return;\n        }\n        const linkDistance = self.linkDistance;\n        // the graph-theoretic distance (shortest path distance) matrix\n        const adjMatrix = getAdjMatrix({ nodes, edges }, false);\n        const distances = floydWarshall(adjMatrix);\n        self.handleInfinity(distances);\n        // scale the ideal edge length acoording to linkDistance\n        const scaledD = scaleMatrix(distances, linkDistance);\n        self.scaledDistances = scaledD;\n        // get positions by MDS\n        const positions = self.runMDS();\n        self.positions = positions;\n        positions.forEach((p, i) => {\n            nodes[i].x = p[0] + center[0];\n            nodes[i].y = p[1] + center[1];\n        });\n        if (self.onLayoutEnd)\n            self.onLayoutEnd();\n        return {\n            nodes,\n            edges\n        };\n    }\n    /**\n     * mds 算法\n     * @return {array} positions 计算后的节点位置数组\n     */\n    runMDS() {\n        const self = this;\n        const dimension = 2;\n        const distances = self.scaledDistances;\n        // square distances\n        const M = MLMatrix.mul(MLMatrix.pow(distances, 2), -0.5);\n        // double centre the rows/columns\n        const rowMeans = M.mean(\"row\");\n        const colMeans = M.mean(\"column\");\n        const totalMean = M.mean();\n        M.add(totalMean)\n            .subRowVector(rowMeans)\n            .subColumnVector(colMeans);\n        // take the SVD of the double centred matrix, and return the\n        // points from it\n        const ret = new SingularValueDecomposition(M);\n        const eigenValues = MLMatrix.sqrt(ret.diagonalMatrix).diagonal();\n        return ret.leftSingularVectors.toJSON().map((row) => {\n            return MLMatrix.mul([row], [eigenValues])\n                .toJSON()[0]\n                .splice(0, dimension);\n        });\n    }\n    handleInfinity(distances) {\n        let maxDistance = -999999;\n        distances.forEach((row) => {\n            row.forEach((value) => {\n                if (value === Infinity) {\n                    return;\n                }\n                if (maxDistance < value) {\n                    maxDistance = value;\n                }\n            });\n        });\n        distances.forEach((row, i) => {\n            row.forEach((value, j) => {\n                if (value === Infinity) {\n                    distances[i][j] = maxDistance;\n                }\n            });\n        });\n    }\n    getType() {\n        return \"mds\";\n    }\n}\n//# sourceMappingURL=mds.js.map"]},"metadata":{},"sourceType":"module"}