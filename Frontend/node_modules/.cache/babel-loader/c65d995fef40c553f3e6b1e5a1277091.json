{"ast":null,"code":"import _classCallCheck from \"/Users/liuzhenwei/Desktop/Respiration_React/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/liuzhenwei/Desktop/Respiration_React/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/liuzhenwei/Desktop/Respiration_React/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/liuzhenwei/Desktop/Respiration_React/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { Base } from \"../base\";\nimport { getEdgeTerminal, isArray, isNumber, isObject } from \"../../util\";\nimport Body from './body';\nimport Quad from './quad';\nimport QuadTree from './quadTree';\nexport var ForceAtlas2Layout = /*#__PURE__*/function (_Base) {\n  _inherits(ForceAtlas2Layout, _Base);\n\n  var _super = _createSuper(ForceAtlas2Layout);\n\n  function ForceAtlas2Layout(options) {\n    var _this;\n\n    _classCallCheck(this, ForceAtlas2Layout);\n\n    _this = _super.call(this);\n    /** 布局中心 */\n\n    _this.center = [0, 0];\n    /** 宽度 */\n\n    _this.width = 300;\n    /** 高度 */\n\n    _this.height = 300;\n    _this.nodes = [];\n    _this.edges = [];\n    /**\n     * the parameter for repulsive forces,\n     * it will scale the layout but won't change the layout\n     * larger the kr, looser the layout\n     * @type  {number}\n     */\n\n    _this.kr = 5;\n    /**\n     * the parameter for gravity forces\n     * @type  {number}\n     */\n\n    _this.kg = 1;\n    /**\n     * modes:\n     * 'normal' for normal using\n     * 'linlog' for compact clusters.\n     * @type  {string}\n     */\n\n    _this.mode = 'normal';\n    /**\n     * whether preventing the node overlapping\n     * @type  {boolean}\n     */\n\n    _this.preventOverlap = false;\n    /**\n     * whether active the dissuade hub mode\n     * true: grant authorities (nodes with a high indegree)\n     * a more central position than hubs (nodes with a high outdegree)\n     * @type  {boolean}\n     */\n\n    _this.dissuadeHubs = false;\n    /**\n     * whether active the barnes hut optimization on computing repulsive forces\n     * @type  {boolean}\n     */\n\n    _this.barnesHut = undefined;\n    /**\n     * the max iteration number\n     * @type  {number}\n     */\n\n    _this.maxIteration = 0;\n    /**\n     * control the global velocity\n     * defualt: 0.1(gephi)\n     * @type  {number}\n     */\n\n    _this.ks = 0.1;\n    /**\n     * the max global velocity\n     * @type  {number}\n     */\n\n    _this.ksmax = 10;\n    /**\n     * the tolerance for the global swinging\n     * @type  {number}\n     */\n\n    _this.tao = 0.1;\n    /**\n     * the function of layout complete listener, display the legend and minimap after layout\n     * @type  {function}\n     */\n\n    _this.onLayoutEnd = function () {};\n    /**\n     * activate prune or not.\n     * prune the leaves during most iterations, layout the leaves in the last 50 iteraitons.\n     * if prune === '', it will be activated when the nodes number > 100\n     * note that it will reduce the quality of the layout\n     * @type  {boolean}\n     */\n\n\n    _this.prune = undefined;\n\n    _this.updateCfg(options);\n\n    return _this;\n  }\n\n  _createClass(ForceAtlas2Layout, [{\n    key: \"getDefaultCfg\",\n    value: function getDefaultCfg() {\n      return {};\n    } // execute the layout\n\n  }, {\n    key: \"execute\",\n    value: function execute() {\n      var self = this;\n      var nodes = self.nodes,\n          onLayoutEnd = self.onLayoutEnd,\n          prune = self.prune;\n      var maxIteration = self.maxIteration;\n\n      if (!self.width && typeof window !== \"undefined\") {\n        self.width = window.innerWidth;\n      }\n\n      if (!self.height && typeof window !== \"undefined\") {\n        self.height = window.innerHeight;\n      } // the whidth of each nodes\n\n\n      var sizes = [];\n      var nodeNum = nodes.length;\n\n      for (var i = 0; i < nodeNum; i += 1) {\n        var node = nodes[i];\n        var nodeWidth = 10;\n        var nodeHeight = 10;\n\n        if (isNumber(node.size)) {\n          nodeWidth = node.size;\n          nodeHeight = node.size;\n        }\n\n        if (isArray(node.size)) {\n          if (!isNaN(node.size[0])) nodeWidth = node.size[0];\n          if (!isNaN(node.size[1])) nodeHeight = node.size[1];\n        } else if (isObject(node.size)) {\n          nodeWidth = node.size.width;\n          nodeHeight = node.size.height;\n        }\n\n        if (self.getWidth && !isNaN(self.getWidth(node))) nodeHeight = self.getWidth(node);\n        if (self.getHeight && !isNaN(self.getHeight(node))) nodeWidth = self.getHeight(node);\n        var maxSize = Math.max(nodeWidth, nodeHeight);\n        sizes.push(maxSize);\n      }\n\n      if (self.barnesHut === undefined && nodeNum > 250) self.barnesHut = true;\n      if (self.prune === undefined && nodeNum > 100) self.prune = true;\n\n      if (this.maxIteration === 0 && !self.prune) {\n        maxIteration = 250;\n        if (nodeNum <= 200 && nodeNum > 100) maxIteration = 1000;else if (nodeNum > 200) maxIteration = 1200;\n        this.maxIteration = maxIteration;\n      } else if (this.maxIteration === 0 && prune) {\n        maxIteration = 100;\n        if (nodeNum <= 200 && nodeNum > 100) maxIteration = 500;else if (nodeNum > 200) maxIteration = 950;\n        this.maxIteration = maxIteration;\n      }\n\n      if (!self.kr) {\n        self.kr = 50;\n        if (nodeNum > 100 && nodeNum <= 500) self.kr = 20;else if (nodeNum > 500) self.kr = 1;\n      }\n\n      if (!self.kg) {\n        self.kg = 20;\n        if (nodeNum > 100 && nodeNum <= 500) self.kg = 10;else if (nodeNum > 500) self.kg = 1;\n      }\n\n      this.nodes = self.updateNodesByForces(sizes);\n      onLayoutEnd();\n    }\n  }, {\n    key: \"updateNodesByForces\",\n    value: function updateNodesByForces(sizes) {\n      var self = this;\n      var edges = self.edges,\n          maxIteration = self.maxIteration;\n      var nodes = self.nodes;\n      var nonLoopEdges = edges.filter(function (edge) {\n        var source = getEdgeTerminal(edge, 'source');\n        var target = getEdgeTerminal(edge, 'target');\n        return source !== target;\n      });\n      var size = nodes.length;\n      var esize = nonLoopEdges.length;\n      var degrees = [];\n      var idMap = {};\n      var edgeEndsIdMap = {}; // tslint:disable-next-line\n\n      var Es = [];\n\n      for (var i = 0; i < size; i += 1) {\n        idMap[nodes[i].id] = i;\n        degrees[i] = 0;\n\n        if (nodes[i].x === undefined || isNaN(nodes[i].x)) {\n          nodes[i].x = Math.random() * 1000;\n        }\n\n        if (nodes[i].y === undefined || isNaN(nodes[i].y)) {\n          nodes[i].y = Math.random() * 1000;\n        }\n\n        Es.push({\n          x: nodes[i].x,\n          y: nodes[i].y\n        });\n      }\n\n      for (var _i = 0; _i < esize; _i += 1) {\n        var node1 = void 0;\n        var node2 = void 0;\n        var sIdx = 0;\n        var tIdx = 0;\n\n        for (var j = 0; j < size; j += 1) {\n          var source = getEdgeTerminal(nonLoopEdges[_i], 'source');\n          var target = getEdgeTerminal(nonLoopEdges[_i], 'target');\n\n          if (nodes[j].id === source) {\n            node1 = nodes[j];\n            sIdx = j;\n          } else if (nodes[j].id === target) {\n            node2 = nodes[j];\n            tIdx = j;\n          }\n\n          edgeEndsIdMap[_i] = {\n            sourceIdx: sIdx,\n            targetIdx: tIdx\n          };\n        }\n\n        if (node1) degrees[idMap[node1.id]] += 1;\n        if (node2) degrees[idMap[node2.id]] += 1;\n      }\n\n      var iteration = maxIteration;\n      nodes = this.iterate(iteration, idMap, edgeEndsIdMap, esize, degrees, sizes); // if prune, place the leaves around their parents, and then re-layout for several iterations.\n\n      if (self.prune) {\n        for (var _j = 0; _j < esize; _j += 1) {\n          if (degrees[edgeEndsIdMap[_j].sourceIdx] <= 1) {\n            nodes[edgeEndsIdMap[_j].sourceIdx].x = nodes[edgeEndsIdMap[_j].targetIdx].x;\n            nodes[edgeEndsIdMap[_j].sourceIdx].y = nodes[edgeEndsIdMap[_j].targetIdx].y;\n          } else if (degrees[edgeEndsIdMap[_j].targetIdx] <= 1) {\n            nodes[edgeEndsIdMap[_j].targetIdx].x = nodes[edgeEndsIdMap[_j].sourceIdx].x;\n            nodes[edgeEndsIdMap[_j].targetIdx].y = nodes[edgeEndsIdMap[_j].sourceIdx].y;\n          }\n        }\n\n        self.prune = false;\n        self.barnesHut = false;\n        iteration = 100;\n        nodes = this.iterate(iteration, idMap, edgeEndsIdMap, esize, degrees, sizes);\n      }\n\n      return nodes;\n    }\n  }, {\n    key: \"iterate\",\n    value: function iterate(iteration, idMap, edgeEndsIdMap, esize, degrees, sizes) {\n      var self = this;\n      var nodes = self.nodes;\n      var kr = self.kr,\n          preventOverlap = self.preventOverlap;\n      var barnesHut = self.barnesHut;\n      var nodeNum = nodes.length;\n      var sg = 0;\n      var krPrime = 100;\n      var iter = iteration;\n      var prevoIter = 50;\n      var forces = [];\n      var preForces = [];\n      var bodies = [];\n\n      for (var i = 0; i < nodeNum; i += 1) {\n        forces[2 * i] = 0;\n        forces[2 * i + 1] = 0;\n\n        if (barnesHut) {\n          var params = {\n            id: i,\n            rx: nodes[i].x,\n            ry: nodes[i].y,\n            mass: 1,\n            g: kr,\n            degree: degrees[i]\n          };\n          bodies[i] = new Body(params);\n        }\n      }\n\n      while (iter > 0) {\n        for (var _i2 = 0; _i2 < nodeNum; _i2 += 1) {\n          preForces[2 * _i2] = forces[2 * _i2];\n          preForces[2 * _i2 + 1] = forces[2 * _i2 + 1];\n          forces[2 * _i2] = 0;\n          forces[2 * _i2 + 1] = 0;\n        } // attractive forces, existing on every actual edge\n\n\n        forces = this.getAttrForces(iter, prevoIter, esize, idMap, edgeEndsIdMap, degrees, sizes, forces); // repulsive forces and Gravity, existing on every node pair\n        // if preventOverlap, using the no-optimized method in the last prevoIter instead.\n\n        if (barnesHut && (preventOverlap && iter > prevoIter || !preventOverlap)) {\n          forces = this.getOptRepGraForces(forces, bodies, degrees);\n        } else {\n          forces = this.getRepGraForces(iter, prevoIter, forces, krPrime, sizes, degrees);\n        } // update the positions\n\n\n        var res = this.updatePos(forces, preForces, sg, degrees);\n        nodes = res.nodes;\n        sg = res.sg;\n        iter--;\n        if (self.tick) self.tick();\n      }\n\n      return nodes;\n    }\n  }, {\n    key: \"getAttrForces\",\n    value: function getAttrForces(iter, prevoIter, esize, idMap, edgeEndsIdMap, degrees, sizes, forces) {\n      var self = this;\n      var nodes = self.nodes,\n          preventOverlap = self.preventOverlap,\n          dissuadeHubs = self.dissuadeHubs,\n          mode = self.mode,\n          prune = self.prune;\n\n      for (var i = 0; i < esize; i += 1) {\n        var sourceNode = nodes[edgeEndsIdMap[i].sourceIdx];\n        var sourceIdx = edgeEndsIdMap[i].sourceIdx;\n        var targetNode = nodes[edgeEndsIdMap[i].targetIdx];\n        var targetIdx = edgeEndsIdMap[i].targetIdx;\n        if (prune && (degrees[sourceIdx] <= 1 || degrees[targetIdx] <= 1)) continue;\n        var dir = [targetNode.x - sourceNode.x, targetNode.y - sourceNode.y];\n        var eucliDis = Math.hypot(dir[0], dir[1]);\n        eucliDis = eucliDis < 0.0001 ? 0.0001 : eucliDis;\n        dir[0] = dir[0] / eucliDis;\n        dir[1] = dir[1] / eucliDis;\n        if (preventOverlap && iter < prevoIter) eucliDis = eucliDis - sizes[sourceIdx] - sizes[targetIdx];\n        var Fa1 = eucliDis; // tslint:disable-line\n\n        var Fa2 = Fa1; // tslint:disable-line\n\n        if (mode === 'linlog') {\n          Fa1 = Math.log(1 + eucliDis);\n          Fa2 = Fa1;\n        }\n\n        if (dissuadeHubs) {\n          Fa1 = eucliDis / degrees[sourceIdx];\n          Fa2 = eucliDis / degrees[targetIdx];\n        }\n\n        if (preventOverlap && iter < prevoIter && eucliDis <= 0) {\n          Fa1 = 0;\n          Fa2 = 0;\n        } else if (preventOverlap && iter < prevoIter && eucliDis > 0) {\n          Fa1 = eucliDis;\n          Fa2 = eucliDis;\n        }\n\n        forces[2 * idMap[sourceNode.id]] += Fa1 * dir[0];\n        forces[2 * idMap[targetNode.id]] -= Fa2 * dir[0];\n        forces[2 * idMap[sourceNode.id] + 1] += Fa1 * dir[1];\n        forces[2 * idMap[targetNode.id] + 1] -= Fa2 * dir[1];\n      }\n\n      return forces;\n    }\n  }, {\n    key: \"getRepGraForces\",\n    value: function getRepGraForces(iter, prevoIter, forces, krPrime, sizes, degrees) {\n      var self = this;\n      var nodes = self.nodes,\n          preventOverlap = self.preventOverlap,\n          kr = self.kr,\n          kg = self.kg,\n          center = self.center,\n          prune = self.prune;\n      var nodeNum = nodes.length;\n\n      for (var i = 0; i < nodeNum; i += 1) {\n        for (var j = i + 1; j < nodeNum; j += 1) {\n          if (prune && (degrees[i] <= 1 || degrees[j] <= 1)) continue;\n          var _dir = [nodes[j].x - nodes[i].x, nodes[j].y - nodes[i].y];\n\n          var _eucliDis = Math.hypot(_dir[0], _dir[1]);\n\n          _eucliDis = _eucliDis < 0.0001 ? 0.0001 : _eucliDis;\n          _dir[0] = _dir[0] / _eucliDis;\n          _dir[1] = _dir[1] / _eucliDis;\n          if (preventOverlap && iter < prevoIter) _eucliDis = _eucliDis - sizes[i] - sizes[j];\n          var Fr = kr * (degrees[i] + 1) * (degrees[j] + 1) / _eucliDis; // tslint:disable-line\n\n          if (preventOverlap && iter < prevoIter && _eucliDis < 0) {\n            Fr = krPrime * (degrees[i] + 1) * (degrees[j] + 1);\n          } else if (preventOverlap && iter < prevoIter && _eucliDis === 0) {\n            Fr = 0;\n          } else if (preventOverlap && iter < prevoIter && _eucliDis > 0) {\n            Fr = kr * (degrees[i] + 1) * (degrees[j] + 1) / _eucliDis;\n          }\n\n          forces[2 * i] -= Fr * _dir[0];\n          forces[2 * j] += Fr * _dir[0];\n          forces[2 * i + 1] -= Fr * _dir[1];\n          forces[2 * j + 1] += Fr * _dir[1];\n        } // gravity\n\n\n        var dir = [nodes[i].x - center[0], nodes[i].y - center[1]];\n        var eucliDis = Math.hypot(dir[0], dir[1]);\n        dir[0] = dir[0] / eucliDis;\n        dir[1] = dir[1] / eucliDis;\n        var Fg = kg * (degrees[i] + 1); // tslint:disable-line\n\n        forces[2 * i] -= Fg * dir[0];\n        forces[2 * i + 1] -= Fg * dir[1];\n      }\n\n      return forces;\n    }\n  }, {\n    key: \"getOptRepGraForces\",\n    value: function getOptRepGraForces(forces, bodies, degrees) {\n      var self = this;\n      var nodes = self.nodes,\n          kg = self.kg,\n          center = self.center,\n          prune = self.prune;\n      var nodeNum = nodes.length;\n      var minx = 9e10;\n      var maxx = -9e10;\n      var miny = 9e10;\n      var maxy = -9e10;\n\n      for (var i = 0; i < nodeNum; i += 1) {\n        if (prune && degrees[i] <= 1) continue;\n        bodies[i].setPos(nodes[i].x, nodes[i].y);\n        if (nodes[i].x >= maxx) maxx = nodes[i].x;\n        if (nodes[i].x <= minx) minx = nodes[i].x;\n        if (nodes[i].y >= maxy) maxy = nodes[i].y;\n        if (nodes[i].y <= miny) miny = nodes[i].y;\n      }\n\n      var width = Math.max(maxx - minx, maxy - miny);\n      var quadParams = {\n        xmid: (maxx + minx) / 2,\n        ymid: (maxy + miny) / 2,\n        length: width,\n        massCenter: center,\n        mass: nodeNum\n      };\n      var quad = new Quad(quadParams);\n      var quadTree = new QuadTree(quad); // build the tree, insert the nodes(quads) into the tree\n\n      for (var _i3 = 0; _i3 < nodeNum; _i3 += 1) {\n        if (prune && degrees[_i3] <= 1) continue;\n        if (bodies[_i3].in(quad)) quadTree.insert(bodies[_i3]);\n      } // update the repulsive forces and the gravity.\n\n\n      for (var _i4 = 0; _i4 < nodeNum; _i4 += 1) {\n        if (prune && degrees[_i4] <= 1) continue;\n\n        bodies[_i4].resetForce();\n\n        quadTree.updateForce(bodies[_i4]);\n        forces[2 * _i4] -= bodies[_i4].fx;\n        forces[2 * _i4 + 1] -= bodies[_i4].fy; // gravity\n\n        var dir = [nodes[_i4].x - center[0], nodes[_i4].y - center[1]];\n        var eucliDis = Math.hypot(dir[0], dir[1]);\n        eucliDis = eucliDis < 0.0001 ? 0.0001 : eucliDis;\n        dir[0] = dir[0] / eucliDis;\n        dir[1] = dir[1] / eucliDis;\n        var Fg = kg * (degrees[_i4] + 1); // tslint:disable-line\n\n        forces[2 * _i4] -= Fg * dir[0];\n        forces[2 * _i4 + 1] -= Fg * dir[1];\n      }\n\n      return forces;\n    }\n  }, {\n    key: \"updatePos\",\n    value: function updatePos(forces, preForces, sg, degrees) {\n      var self = this;\n      var nodes = self.nodes,\n          ks = self.ks,\n          tao = self.tao,\n          prune = self.prune,\n          ksmax = self.ksmax;\n      var nodeNum = nodes.length;\n      var swgns = [];\n      var trans = []; // swg(G) and tra(G)\n\n      var swgG = 0;\n      var traG = 0;\n\n      for (var i = 0; i < nodeNum; i += 1) {\n        if (prune && degrees[i] <= 1) continue;\n        var minus = [forces[2 * i] - preForces[2 * i], forces[2 * i + 1] - preForces[2 * i + 1]];\n        var minusNorm = Math.hypot(minus[0], minus[1]);\n        var add = [forces[2 * i] + preForces[2 * i], forces[2 * i + 1] + preForces[2 * i + 1]];\n        var addNorm = Math.hypot(add[0], add[1]);\n        swgns[i] = minusNorm;\n        trans[i] = addNorm / 2;\n        swgG += (degrees[i] + 1) * swgns[i];\n        traG += (degrees[i] + 1) * trans[i];\n      }\n\n      var preSG = sg;\n      sg = tao * traG / swgG; // tslint:disable-line\n\n      if (preSG !== 0) {\n        sg = sg > 1.5 * preSG ? 1.5 * preSG : sg; // tslint:disable-line\n      } // update the node positions\n\n\n      for (var _i5 = 0; _i5 < nodeNum; _i5 += 1) {\n        if (prune && degrees[_i5] <= 1) continue;\n        var sn = ks * sg / (1 + sg * Math.sqrt(swgns[_i5]));\n        var absForce = Math.hypot(forces[2 * _i5], forces[2 * _i5 + 1]);\n        absForce = absForce < 0.0001 ? 0.0001 : absForce;\n        var max = ksmax / absForce;\n        sn = sn > max ? max : sn;\n        var dnx = sn * forces[2 * _i5];\n        var dny = sn * forces[2 * _i5 + 1];\n        nodes[_i5].x += dnx;\n        nodes[_i5].y += dny;\n      }\n\n      return {\n        nodes: nodes,\n        sg: sg\n      };\n    }\n  }]);\n\n  return ForceAtlas2Layout;\n}(Base);","map":{"version":3,"sources":["../../../src/layout/forceAtlas2/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Base } from \"../base\";\nimport { getEdgeTerminal, isArray, isNumber, isObject } from \"../../util\";\nimport Body from './body';\nimport Quad from './quad';\nimport QuadTree from './quadTree';\nexport class ForceAtlas2Layout extends Base {\n    constructor(options) {\n        super();\n        /** 布局中心 */\n        this.center = [0, 0];\n        /** 宽度 */\n        this.width = 300;\n        /** 高度 */\n        this.height = 300;\n        this.nodes = [];\n        this.edges = [];\n        /**\n         * the parameter for repulsive forces,\n         * it will scale the layout but won't change the layout\n         * larger the kr, looser the layout\n         * @type  {number}\n         */\n        this.kr = 5;\n        /**\n         * the parameter for gravity forces\n         * @type  {number}\n         */\n        this.kg = 1;\n        /**\n         * modes:\n         * 'normal' for normal using\n         * 'linlog' for compact clusters.\n         * @type  {string}\n         */\n        this.mode = 'normal';\n        /**\n         * whether preventing the node overlapping\n         * @type  {boolean}\n         */\n        this.preventOverlap = false;\n        /**\n         * whether active the dissuade hub mode\n         * true: grant authorities (nodes with a high indegree)\n         * a more central position than hubs (nodes with a high outdegree)\n         * @type  {boolean}\n         */\n        this.dissuadeHubs = false;\n        /**\n         * whether active the barnes hut optimization on computing repulsive forces\n         * @type  {boolean}\n         */\n        this.barnesHut = undefined;\n        /**\n         * the max iteration number\n         * @type  {number}\n         */\n        this.maxIteration = 0;\n        /**\n         * control the global velocity\n         * defualt: 0.1(gephi)\n         * @type  {number}\n         */\n        this.ks = 0.1;\n        /**\n         * the max global velocity\n         * @type  {number}\n         */\n        this.ksmax = 10;\n        /**\n         * the tolerance for the global swinging\n         * @type  {number}\n         */\n        this.tao = 0.1;\n        /**\n         * the function of layout complete listener, display the legend and minimap after layout\n         * @type  {function}\n         */\n        this.onLayoutEnd = () => { };\n        /**\n         * activate prune or not.\n         * prune the leaves during most iterations, layout the leaves in the last 50 iteraitons.\n         * if prune === '', it will be activated when the nodes number > 100\n         * note that it will reduce the quality of the layout\n         * @type  {boolean}\n         */\n        this.prune = undefined;\n        this.updateCfg(options);\n    }\n    getDefaultCfg() {\n        return {};\n    }\n    // execute the layout\n    execute() {\n        const self = this;\n        const { nodes, onLayoutEnd, prune, } = self;\n        let maxIteration = self.maxIteration;\n        if (!self.width && typeof window !== \"undefined\") {\n            self.width = window.innerWidth;\n        }\n        if (!self.height && typeof window !== \"undefined\") {\n            self.height = window.innerHeight;\n        }\n        // the whidth of each nodes\n        const sizes = [];\n        const nodeNum = nodes.length;\n        for (let i = 0; i < nodeNum; i += 1) {\n            const node = nodes[i];\n            let nodeWidth = 10;\n            let nodeHeight = 10;\n            if (isNumber(node.size)) {\n                nodeWidth = node.size;\n                nodeHeight = node.size;\n            }\n            if (isArray(node.size)) {\n                if (!isNaN(node.size[0]))\n                    nodeWidth = node.size[0];\n                if (!isNaN(node.size[1]))\n                    nodeHeight = node.size[1];\n            }\n            else if (isObject(node.size)) {\n                nodeWidth = node.size.width;\n                nodeHeight = node.size.height;\n            }\n            if (self.getWidth && !isNaN(self.getWidth(node)))\n                nodeHeight = self.getWidth(node);\n            if (self.getHeight && !isNaN(self.getHeight(node)))\n                nodeWidth = self.getHeight(node);\n            const maxSize = Math.max(nodeWidth, nodeHeight);\n            sizes.push(maxSize);\n        }\n        if (self.barnesHut === undefined && nodeNum > 250)\n            self.barnesHut = true;\n        if (self.prune === undefined && nodeNum > 100)\n            self.prune = true;\n        if (this.maxIteration === 0 && !self.prune) {\n            maxIteration = 250;\n            if (nodeNum <= 200 && nodeNum > 100)\n                maxIteration = 1000;\n            else if (nodeNum > 200)\n                maxIteration = 1200;\n            this.maxIteration = maxIteration;\n        }\n        else if (this.maxIteration === 0 && prune) {\n            maxIteration = 100;\n            if (nodeNum <= 200 && nodeNum > 100)\n                maxIteration = 500;\n            else if (nodeNum > 200)\n                maxIteration = 950;\n            this.maxIteration = maxIteration;\n        }\n        if (!self.kr) {\n            self.kr = 50;\n            if (nodeNum > 100 && nodeNum <= 500)\n                self.kr = 20;\n            else if (nodeNum > 500)\n                self.kr = 1;\n        }\n        if (!self.kg) {\n            self.kg = 20;\n            if (nodeNum > 100 && nodeNum <= 500)\n                self.kg = 10;\n            else if (nodeNum > 500)\n                self.kg = 1;\n        }\n        this.nodes = self.updateNodesByForces(sizes);\n        onLayoutEnd();\n    }\n    updateNodesByForces(sizes) {\n        const self = this;\n        const { edges, maxIteration } = self;\n        let nodes = self.nodes;\n        const nonLoopEdges = edges.filter((edge) => {\n            const source = getEdgeTerminal(edge, 'source');\n            const target = getEdgeTerminal(edge, 'target');\n            return source !== target;\n        });\n        const size = nodes.length;\n        const esize = nonLoopEdges.length;\n        const degrees = [];\n        const idMap = {};\n        const edgeEndsIdMap = {};\n        // tslint:disable-next-line\n        const Es = [];\n        for (let i = 0; i < size; i += 1) {\n            idMap[nodes[i].id] = i;\n            degrees[i] = 0;\n            if (nodes[i].x === undefined || isNaN(nodes[i].x)) {\n                nodes[i].x = Math.random() * 1000;\n            }\n            if (nodes[i].y === undefined || isNaN(nodes[i].y)) {\n                nodes[i].y = Math.random() * 1000;\n            }\n            Es.push({ x: nodes[i].x, y: nodes[i].y });\n        }\n        for (let i = 0; i < esize; i += 1) {\n            let node1;\n            let node2;\n            let sIdx = 0;\n            let tIdx = 0;\n            for (let j = 0; j < size; j += 1) {\n                const source = getEdgeTerminal(nonLoopEdges[i], 'source');\n                const target = getEdgeTerminal(nonLoopEdges[i], 'target');\n                if (nodes[j].id === source) {\n                    node1 = nodes[j];\n                    sIdx = j;\n                }\n                else if (nodes[j].id === target) {\n                    node2 = nodes[j];\n                    tIdx = j;\n                }\n                edgeEndsIdMap[i] = { sourceIdx: sIdx, targetIdx: tIdx };\n            }\n            if (node1)\n                degrees[idMap[node1.id]] += 1;\n            if (node2)\n                degrees[idMap[node2.id]] += 1;\n        }\n        let iteration = maxIteration;\n        nodes = this.iterate(iteration, idMap, edgeEndsIdMap, esize, degrees, sizes);\n        // if prune, place the leaves around their parents, and then re-layout for several iterations.\n        if (self.prune) {\n            for (let j = 0; j < esize; j += 1) {\n                if (degrees[edgeEndsIdMap[j].sourceIdx] <= 1) {\n                    nodes[edgeEndsIdMap[j].sourceIdx].x = nodes[edgeEndsIdMap[j].targetIdx].x;\n                    nodes[edgeEndsIdMap[j].sourceIdx].y = nodes[edgeEndsIdMap[j].targetIdx].y;\n                }\n                else if (degrees[edgeEndsIdMap[j].targetIdx] <= 1) {\n                    nodes[edgeEndsIdMap[j].targetIdx].x = nodes[edgeEndsIdMap[j].sourceIdx].x;\n                    nodes[edgeEndsIdMap[j].targetIdx].y = nodes[edgeEndsIdMap[j].sourceIdx].y;\n                }\n            }\n            self.prune = false;\n            self.barnesHut = false;\n            iteration = 100;\n            nodes = this.iterate(iteration, idMap, edgeEndsIdMap, esize, degrees, sizes);\n        }\n        return nodes;\n    }\n    iterate(iteration, idMap, edgeEndsIdMap, esize, degrees, sizes) {\n        const self = this;\n        let { nodes } = self;\n        const { kr, preventOverlap } = self;\n        const { barnesHut } = self;\n        const nodeNum = nodes.length;\n        let sg = 0;\n        const krPrime = 100;\n        let iter = iteration;\n        const prevoIter = 50;\n        let forces = [];\n        const preForces = [];\n        const bodies = [];\n        for (let i = 0; i < nodeNum; i += 1) {\n            forces[2 * i] = 0;\n            forces[2 * i + 1] = 0;\n            if (barnesHut) {\n                const params = {\n                    id: i,\n                    rx: nodes[i].x,\n                    ry: nodes[i].y,\n                    mass: 1,\n                    g: kr,\n                    degree: degrees[i]\n                };\n                bodies[i] = new Body(params);\n            }\n        }\n        while (iter > 0) {\n            for (let i = 0; i < nodeNum; i += 1) {\n                preForces[2 * i] = forces[2 * i];\n                preForces[2 * i + 1] = forces[2 * i + 1];\n                forces[2 * i] = 0;\n                forces[2 * i + 1] = 0;\n            }\n            // attractive forces, existing on every actual edge\n            forces = this.getAttrForces(iter, prevoIter, esize, idMap, edgeEndsIdMap, degrees, sizes, forces);\n            // repulsive forces and Gravity, existing on every node pair\n            // if preventOverlap, using the no-optimized method in the last prevoIter instead.\n            if (barnesHut && ((preventOverlap && iter > prevoIter) || !preventOverlap)) {\n                forces = this.getOptRepGraForces(forces, bodies, degrees);\n            }\n            else {\n                forces = this.getRepGraForces(iter, prevoIter, forces, krPrime, sizes, degrees);\n            }\n            // update the positions\n            const res = this.updatePos(forces, preForces, sg, degrees);\n            nodes = res.nodes;\n            sg = res.sg;\n            iter--;\n            if (self.tick)\n                self.tick();\n        }\n        return nodes;\n    }\n    getAttrForces(iter, prevoIter, esize, idMap, edgeEndsIdMap, degrees, sizes, forces) {\n        const self = this;\n        const { nodes, preventOverlap, dissuadeHubs, mode, prune } = self;\n        for (let i = 0; i < esize; i += 1) {\n            const sourceNode = nodes[edgeEndsIdMap[i].sourceIdx];\n            const sourceIdx = edgeEndsIdMap[i].sourceIdx;\n            const targetNode = nodes[edgeEndsIdMap[i].targetIdx];\n            const targetIdx = edgeEndsIdMap[i].targetIdx;\n            if (prune && (degrees[sourceIdx] <= 1 || degrees[targetIdx] <= 1))\n                continue;\n            const dir = [targetNode.x - sourceNode.x, targetNode.y - sourceNode.y];\n            let eucliDis = Math.hypot(dir[0], dir[1]);\n            eucliDis = eucliDis < 0.0001 ? 0.0001 : eucliDis;\n            dir[0] = dir[0] / eucliDis;\n            dir[1] = dir[1] / eucliDis;\n            if (preventOverlap && iter < prevoIter)\n                eucliDis = eucliDis - sizes[sourceIdx] - sizes[targetIdx];\n            let Fa1 = eucliDis; // tslint:disable-line\n            let Fa2 = Fa1; // tslint:disable-line\n            if (mode === 'linlog') {\n                Fa1 = Math.log(1 + eucliDis);\n                Fa2 = Fa1;\n            }\n            if (dissuadeHubs) {\n                Fa1 = eucliDis / degrees[sourceIdx];\n                Fa2 = eucliDis / degrees[targetIdx];\n            }\n            if (preventOverlap && iter < prevoIter && eucliDis <= 0) {\n                Fa1 = 0;\n                Fa2 = 0;\n            }\n            else if (preventOverlap && iter < prevoIter && eucliDis > 0) {\n                Fa1 = eucliDis;\n                Fa2 = eucliDis;\n            }\n            forces[2 * idMap[sourceNode.id]] += Fa1 * dir[0];\n            forces[2 * idMap[targetNode.id]] -= Fa2 * dir[0];\n            forces[2 * idMap[sourceNode.id] + 1] += Fa1 * dir[1];\n            forces[2 * idMap[targetNode.id] + 1] -= Fa2 * dir[1];\n        }\n        return forces;\n    }\n    getRepGraForces(iter, prevoIter, forces, krPrime, sizes, degrees) {\n        const self = this;\n        const { nodes, preventOverlap, kr, kg, center, prune } = self;\n        const nodeNum = nodes.length;\n        for (let i = 0; i < nodeNum; i += 1) {\n            for (let j = i + 1; j < nodeNum; j += 1) {\n                if (prune && (degrees[i] <= 1 || degrees[j] <= 1))\n                    continue;\n                const dir = [nodes[j].x - nodes[i].x, nodes[j].y - nodes[i].y];\n                let eucliDis = Math.hypot(dir[0], dir[1]);\n                eucliDis = eucliDis < 0.0001 ? 0.0001 : eucliDis;\n                dir[0] = dir[0] / eucliDis;\n                dir[1] = dir[1] / eucliDis;\n                if (preventOverlap && iter < prevoIter)\n                    eucliDis = eucliDis - sizes[i] - sizes[j];\n                let Fr = kr * (degrees[i] + 1) * (degrees[j] + 1) / eucliDis; // tslint:disable-line\n                if (preventOverlap && iter < prevoIter && eucliDis < 0) {\n                    Fr = krPrime * (degrees[i] + 1) * (degrees[j] + 1);\n                }\n                else if (preventOverlap && iter < prevoIter && eucliDis === 0) {\n                    Fr = 0;\n                }\n                else if (preventOverlap && iter < prevoIter && eucliDis > 0) {\n                    Fr = kr * (degrees[i] + 1) * (degrees[j] + 1) / eucliDis;\n                }\n                forces[2 * i] -= Fr * dir[0];\n                forces[2 * j] += Fr * dir[0];\n                forces[2 * i + 1] -= Fr * dir[1];\n                forces[2 * j + 1] += Fr * dir[1];\n            }\n            // gravity\n            const dir = [nodes[i].x - center[0], nodes[i].y - center[1]];\n            const eucliDis = Math.hypot(dir[0], dir[1]);\n            dir[0] = dir[0] / eucliDis;\n            dir[1] = dir[1] / eucliDis;\n            const Fg = kg * (degrees[i] + 1); // tslint:disable-line\n            forces[2 * i] -= Fg * dir[0];\n            forces[2 * i + 1] -= Fg * dir[1];\n        }\n        return forces;\n    }\n    getOptRepGraForces(forces, bodies, degrees) {\n        const self = this;\n        const { nodes, kg, center, prune } = self;\n        const nodeNum = nodes.length;\n        let minx = 9e10;\n        let maxx = -9e10;\n        let miny = 9e10;\n        let maxy = -9e10;\n        for (let i = 0; i < nodeNum; i += 1) {\n            if (prune && (degrees[i] <= 1))\n                continue;\n            bodies[i].setPos(nodes[i].x, nodes[i].y);\n            if (nodes[i].x >= maxx)\n                maxx = nodes[i].x;\n            if (nodes[i].x <= minx)\n                minx = nodes[i].x;\n            if (nodes[i].y >= maxy)\n                maxy = nodes[i].y;\n            if (nodes[i].y <= miny)\n                miny = nodes[i].y;\n        }\n        const width = Math.max(maxx - minx, maxy - miny);\n        const quadParams = {\n            xmid: (maxx + minx) / 2,\n            ymid: (maxy + miny) / 2,\n            length: width,\n            massCenter: center,\n            mass: nodeNum\n        };\n        const quad = new Quad(quadParams);\n        const quadTree = new QuadTree(quad);\n        // build the tree, insert the nodes(quads) into the tree\n        for (let i = 0; i < nodeNum; i += 1) {\n            if (prune && (degrees[i] <= 1))\n                continue;\n            if (bodies[i].in(quad))\n                quadTree.insert(bodies[i]);\n        }\n        // update the repulsive forces and the gravity.\n        for (let i = 0; i < nodeNum; i += 1) {\n            if (prune && (degrees[i] <= 1))\n                continue;\n            bodies[i].resetForce();\n            quadTree.updateForce(bodies[i]);\n            forces[2 * i] -= bodies[i].fx;\n            forces[2 * i + 1] -= bodies[i].fy;\n            // gravity\n            const dir = [nodes[i].x - center[0], nodes[i].y - center[1]];\n            let eucliDis = Math.hypot(dir[0], dir[1]);\n            eucliDis = eucliDis < 0.0001 ? 0.0001 : eucliDis;\n            dir[0] = dir[0] / eucliDis;\n            dir[1] = dir[1] / eucliDis;\n            const Fg = kg * (degrees[i] + 1); // tslint:disable-line\n            forces[2 * i] -= Fg * dir[0];\n            forces[2 * i + 1] -= Fg * dir[1];\n        }\n        return forces;\n    }\n    updatePos(forces, preForces, sg, degrees) {\n        const self = this;\n        const { nodes, ks, tao, prune, ksmax } = self;\n        const nodeNum = nodes.length;\n        const swgns = [];\n        const trans = [];\n        // swg(G) and tra(G)\n        let swgG = 0;\n        let traG = 0;\n        for (let i = 0; i < nodeNum; i += 1) {\n            if (prune && (degrees[i] <= 1))\n                continue;\n            const minus = [forces[2 * i] - preForces[2 * i],\n                forces[2 * i + 1] - preForces[2 * i + 1]\n            ];\n            const minusNorm = Math.hypot(minus[0], minus[1]);\n            const add = [forces[2 * i] + preForces[2 * i],\n                forces[2 * i + 1] + preForces[2 * i + 1]\n            ];\n            const addNorm = Math.hypot(add[0], add[1]);\n            swgns[i] = minusNorm;\n            trans[i] = addNorm / 2;\n            swgG += (degrees[i] + 1) * swgns[i];\n            traG += (degrees[i] + 1) * trans[i];\n        }\n        const preSG = sg;\n        sg = tao * traG / swgG; // tslint:disable-line\n        if (preSG !== 0) {\n            sg = sg > (1.5 * preSG) ? (1.5 * preSG) : sg; // tslint:disable-line\n        }\n        // update the node positions\n        for (let i = 0; i < nodeNum; i += 1) {\n            if (prune && (degrees[i] <= 1))\n                continue;\n            let sn = ks * sg / (1 + sg * Math.sqrt(swgns[i]));\n            let absForce = Math.hypot(forces[2 * i], forces[2 * i + 1]);\n            absForce = absForce < 0.0001 ? 0.0001 : absForce;\n            const max = ksmax / absForce;\n            sn = sn > max ? max : sn;\n            const dnx = sn * forces[2 * i];\n            const dny = sn * forces[2 * i + 1];\n            nodes[i].x += dnx;\n            nodes[i].y += dny;\n        }\n        return { nodes, sg };\n    }\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}