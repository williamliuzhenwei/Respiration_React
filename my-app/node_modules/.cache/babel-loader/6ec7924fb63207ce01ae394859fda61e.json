{"ast":null,"code":"import _regeneratorRuntime from \"/Users/liuzhenwei/Desktop/Respiration_React/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _classCallCheck from \"/Users/liuzhenwei/Desktop/Respiration_React/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/liuzhenwei/Desktop/Respiration_React/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/liuzhenwei/Desktop/Respiration_React/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/liuzhenwei/Desktop/Respiration_React/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n// @ts-nocheck\n\n/**\n * @fileOverview fruchterman layout\n * @author shiwu.wyy@antfin.com\n */\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { Base } from \"../base\";\nimport { isNumber } from \"../../util\"; // @ts-ignore\n\nimport { World } from \"@antv/g-webgpu\";\nimport { proccessToFunc, buildTextureDataWithTwoEdgeAttr, arrayToTextureData } from \"../../util/gpu\";\nimport { getDegree } from \"../../util/math\";\nimport { gForceBundle, aveMovementBundle } from \"./gForceShader\";\nimport { LAYOUT_MESSAGE } from \"../constants\";\n/**\n * graphin 中的 force 布局\n */\n\nexport var GForceGPULayout = /*#__PURE__*/function (_Base) {\n  _inherits(GForceGPULayout, _Base);\n\n  var _super = _createSuper(GForceGPULayout);\n\n  function GForceGPULayout(options) {\n    var _this;\n\n    _classCallCheck(this, GForceGPULayout);\n\n    _this = _super.call(this);\n    /** 停止迭代的最大迭代数 */\n\n    _this.maxIteration = 1000;\n    /** 弹簧引力系数 */\n\n    _this.edgeStrength = 200;\n    /** 斥力系数 */\n\n    _this.nodeStrength = 1000;\n    /** 库伦系数 */\n\n    _this.coulombDisScale = 0.005;\n    /** 阻尼系数 */\n\n    _this.damping = 0.9;\n    /** 最大速度 */\n\n    _this.maxSpeed = 1000;\n    /** 一次迭代的平均移动距离小于该值时停止迭代 */\n\n    _this.minMovement = 0.5;\n    /** 迭代中衰减 */\n\n    _this.interval = 0.02;\n    /** 斥力的一个系数 */\n\n    _this.factor = 1;\n    /** 理想边长 */\n\n    _this.linkDistance = 1;\n    /** 重力大小 */\n\n    _this.gravity = 10;\n    /** 是否启用web worker。前提是在web worker里执行布局，否则无效\t*/\n\n    _this.workerEnabled = false;\n    _this.nodes = [];\n    _this.edges = [];\n    _this.width = 300;\n    _this.height = 300;\n    _this.nodeMap = {};\n    _this.nodeIdxMap = {};\n\n    _this.updateCfg(options);\n\n    return _this;\n  }\n\n  _createClass(GForceGPULayout, [{\n    key: \"getDefaultCfg\",\n    value: function getDefaultCfg() {\n      return {\n        maxIteration: 2000,\n        gravity: 10,\n        clustering: false,\n        clusterGravity: 10\n      };\n    }\n    /**\n     * 执行布局\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var self, nodes, center, nodeMap, nodeIdxMap;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                self = this;\n                nodes = self.nodes;\n\n                if (!(!nodes || nodes.length === 0)) {\n                  _context.next = 5;\n                  break;\n                }\n\n                if (self.onLayoutEnd) self.onLayoutEnd();\n                return _context.abrupt(\"return\");\n\n              case 5:\n                if (!self.width && typeof window !== \"undefined\") {\n                  self.width = window.innerWidth;\n                }\n\n                if (!self.height && typeof window !== \"undefined\") {\n                  self.height = window.innerHeight;\n                }\n\n                if (!self.center) {\n                  self.center = [self.width / 2, self.height / 2];\n                }\n\n                center = self.center;\n\n                if (!(nodes.length === 1)) {\n                  _context.next = 14;\n                  break;\n                }\n\n                nodes[0].x = center[0];\n                nodes[0].y = center[1];\n                if (self.onLayoutEnd) self.onLayoutEnd();\n                return _context.abrupt(\"return\");\n\n              case 14:\n                nodeMap = {};\n                nodeIdxMap = {};\n                nodes.forEach(function (node, i) {\n                  if (!isNumber(node.x)) node.x = Math.random() * self.width;\n                  if (!isNumber(node.y)) node.y = Math.random() * self.height;\n                  nodeMap[node.id] = node;\n                  nodeIdxMap[node.id] = i;\n                });\n                self.nodeMap = nodeMap;\n                self.nodeIdxMap = nodeIdxMap;\n                self.nodeStrength = proccessToFunc(self.nodeStrength, 1);\n                self.edgeStrength = proccessToFunc(self.edgeStrength, 1); // layout\n\n                _context.next = 23;\n                return self.run();\n\n              case 23:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n  }, {\n    key: \"executeWithWorker\",\n    value: function executeWithWorker(canvas, ctx) {\n      var self = this;\n      var nodes = self.nodes;\n      var center = self.center;\n\n      if (!nodes || nodes.length === 0) {\n        return;\n      }\n\n      if (nodes.length === 1) {\n        nodes[0].x = center[0];\n        nodes[0].y = center[1];\n        return;\n      }\n\n      var nodeMap = {};\n      var nodeIdxMap = {};\n      nodes.forEach(function (node, i) {\n        if (!isNumber(node.x)) node.x = Math.random() * self.width;\n        if (!isNumber(node.y)) node.y = Math.random() * self.height;\n        nodeMap[node.id] = node;\n        nodeIdxMap[node.id] = i;\n      });\n      self.nodeMap = nodeMap;\n      self.nodeIdxMap = nodeIdxMap;\n      self.nodeStrength = proccessToFunc(self.nodeStrength, 1);\n      self.edgeStrength = proccessToFunc(self.edgeStrength, 1); // layout\n\n      self.run(canvas, ctx);\n    }\n  }, {\n    key: \"run\",\n    value: function run(canvas, ctx) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var _this2 = this;\n\n        var self, nodes, edges, maxIteration, numParticles, _buildTextureDataWith, maxEdgePerVetex, nodesEdgesArray, masses, nodeStrengths, centerXs, centerYs, centerGravities, fxs, fys, gravity, center, nodeAttributeArray1, nodeAttributeArray2, workerEnabled, world, onLayoutEnd, initPreviousData, i, kernelGForce, kernelAveMovement, execute;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                self = this;\n                nodes = self.nodes;\n                edges = self.edges;\n                maxIteration = self.maxIteration;\n\n                if (!self.width && typeof window !== \"undefined\") {\n                  self.width = window.innerWidth;\n                }\n\n                if (!self.height && typeof window !== \"undefined\") {\n                  self.height = window.innerHeight;\n                }\n\n                numParticles = nodes.length;\n                self.linkDistance = proccessToFunc(self.linkDistance);\n                self.edgeStrength = proccessToFunc(self.edgeStrength);\n                _buildTextureDataWith = buildTextureDataWithTwoEdgeAttr(nodes, edges, self.linkDistance, self.edgeStrength), maxEdgePerVetex = _buildTextureDataWith.maxEdgePerVetex, nodesEdgesArray = _buildTextureDataWith.array; // init degree for mass\n\n                self.degrees = getDegree(nodes.length, self.nodeIdxMap, edges);\n                masses = [];\n                nodeStrengths = [];\n                centerXs = [];\n                centerYs = [];\n                centerGravities = [];\n                fxs = [];\n                fys = [];\n\n                if (!self.getMass) {\n                  self.getMass = function (d) {\n                    return self.degrees[self.nodeIdxMap[d.id]] || 1;\n                  };\n                }\n\n                gravity = self.gravity;\n                center = self.center;\n                nodes.forEach(function (node, i) {\n                  masses.push(self.getMass(node));\n                  nodeStrengths.push(self.nodeStrength(node));\n                  if (!self.degrees[i]) self.degrees[i] = 0;\n                  var nodeGravity = [center[0], center[1], gravity];\n\n                  if (self.getCenter) {\n                    var customCenter = self.getCenter(node, self.degrees[i]);\n\n                    if (customCenter && isNumber(customCenter[0]) && isNumber(customCenter[1]) && isNumber(customCenter[2])) {\n                      nodeGravity = customCenter;\n                    }\n                  }\n\n                  centerXs.push(nodeGravity[0]);\n                  centerYs.push(nodeGravity[1]);\n                  centerGravities.push(nodeGravity[2]);\n\n                  if (isNumber(node.fx) && isNumber(node.fy)) {\n                    fxs.push(node.fx || 0.001);\n                    fys.push(node.fy || 0.001);\n                  } else {\n                    fxs.push(0);\n                    fys.push(0);\n                  }\n                }); // 每个节点的额外属性占两个数组各一格，nodeAttributeArray1 中是：mass, degree, nodeSterngth, 0\n\n                nodeAttributeArray1 = arrayToTextureData([masses, self.degrees, nodeStrengths, fxs]); // nodeAttributeArray2 中是：centerX, centerY, gravity, 0,\n\n                nodeAttributeArray2 = arrayToTextureData([centerXs, centerYs, centerGravities, fys]);\n                workerEnabled = self.workerEnabled;\n\n                if (workerEnabled) {\n                  world = World.create({\n                    canvas: canvas,\n                    engineOptions: {\n                      supportCompute: true\n                    }\n                  });\n                } else {\n                  world = World.create({\n                    engineOptions: {\n                      supportCompute: true\n                    }\n                  });\n                } // TODO: 最终的预编译代码放入到 gForceShader.ts 中直接引入，不再需要下面三行\n                // const compiler = new Compiler();\n                // const gForceBundle = compiler.compileBundle(gForceCode);\n                // console.log(gForceBundle.toString());\n\n\n                onLayoutEnd = self.onLayoutEnd;\n                initPreviousData = [];\n                nodesEdgesArray.forEach(function (value) {\n                  initPreviousData.push(value);\n                });\n\n                for (i = 0; i < 4; i++) {\n                  initPreviousData.push(0);\n                }\n\n                kernelGForce = world.createKernel(gForceBundle).setDispatch([numParticles, 1, 1]).setBinding({\n                  u_Data: nodesEdgesArray,\n                  u_damping: self.damping,\n                  u_maxSpeed: self.maxSpeed,\n                  u_minMovement: self.minMovement,\n                  u_coulombDisScale: self.coulombDisScale,\n                  u_factor: self.factor,\n                  u_NodeAttributeArray1: nodeAttributeArray1,\n                  u_NodeAttributeArray2: nodeAttributeArray2,\n                  MAX_EDGE_PER_VERTEX: maxEdgePerVetex,\n                  VERTEX_COUNT: numParticles,\n                  u_AveMovement: initPreviousData,\n                  u_interval: self.interval // 每次迭代更新，首次设置为 interval，在 onIterationCompleted 中更新\n\n                }); // const aveMovementBundle = compiler.compileBundle(aveMovementCode);\n                // console.log(aveMovementBundle.toString());\n\n                kernelAveMovement = world.createKernel(aveMovementBundle).setDispatch([1, 1, 1]).setBinding({\n                  u_Data: nodesEdgesArray,\n                  VERTEX_COUNT: numParticles,\n                  u_AveMovement: [0, 0, 0, 0]\n                }); // 执行迭代\n                // let midRes = nodesEdgesArray;\n\n                execute = function execute() {\n                  return __awaiter(_this2, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n                    var _i, stepInterval, finalParticleData;\n\n                    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                      while (1) {\n                        switch (_context2.prev = _context2.next) {\n                          case 0:\n                            _i = 0;\n\n                          case 1:\n                            if (!(_i < maxIteration)) {\n                              _context2.next = 12;\n                              break;\n                            }\n\n                            _context2.next = 4;\n                            return kernelGForce.execute();\n\n                          case 4:\n                            // midRes = await kernelGForce.getOutput();\n                            // 每次迭代完成后\n                            // 计算平均位移，用于提前终止迭代\n                            kernelAveMovement.setBinding({\n                              u_Data: kernelGForce\n                            }); // eslint-disable-next-line no-await-in-loop\n\n                            _context2.next = 7;\n                            return kernelAveMovement.execute();\n\n                          case 7:\n                            // 更新衰减函数\n                            stepInterval = Math.max(0.02, self.interval - _i * 0.002);\n                            kernelGForce.setBinding({\n                              u_interval: stepInterval,\n                              u_AveMovement: kernelAveMovement\n                            });\n\n                          case 9:\n                            _i++;\n                            _context2.next = 1;\n                            break;\n\n                          case 12:\n                            _context2.next = 14;\n                            return kernelGForce.getOutput();\n\n                          case 14:\n                            finalParticleData = _context2.sent;\n\n                            // 所有迭代完成后\n                            if (canvas) {\n                              // 传递数据给主线程\n                              ctx.postMessage({\n                                type: LAYOUT_MESSAGE.GPUEND,\n                                vertexEdgeData: finalParticleData // edgeIndexBufferData,\n\n                              });\n                            } else {\n                              nodes.forEach(function (node, i) {\n                                var x = finalParticleData[4 * i];\n                                var y = finalParticleData[4 * i + 1];\n                                node.x = x;\n                                node.y = y;\n                              });\n                            }\n\n                            if (onLayoutEnd) onLayoutEnd();\n\n                          case 17:\n                          case \"end\":\n                            return _context2.stop();\n                        }\n                      }\n                    }, _callee2);\n                  }));\n                };\n\n                _context3.next = 35;\n                return execute();\n\n              case 35:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n    }\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      return \"gForce-gpu\";\n    }\n  }]);\n\n  return GForceGPULayout;\n}(Base);","map":{"version":3,"sources":["../../../src/layout/gpu/gForce.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["// @ts-nocheck\n/**\n * @fileOverview fruchterman layout\n * @author shiwu.wyy@antfin.com\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Base } from \"../base\";\nimport { isNumber } from \"../../util\";\n// @ts-ignore\nimport { World } from \"@antv/g-webgpu\";\nimport { proccessToFunc, buildTextureDataWithTwoEdgeAttr, arrayToTextureData } from \"../../util/gpu\";\nimport { getDegree } from \"../../util/math\";\nimport { gForceBundle, aveMovementBundle } from \"./gForceShader\";\nimport { LAYOUT_MESSAGE } from \"../constants\";\n/**\n * graphin 中的 force 布局\n */\nexport class GForceGPULayout extends Base {\n    constructor(options) {\n        super();\n        /** 停止迭代的最大迭代数 */\n        this.maxIteration = 1000;\n        /** 弹簧引力系数 */\n        this.edgeStrength = 200;\n        /** 斥力系数 */\n        this.nodeStrength = 1000;\n        /** 库伦系数 */\n        this.coulombDisScale = 0.005;\n        /** 阻尼系数 */\n        this.damping = 0.9;\n        /** 最大速度 */\n        this.maxSpeed = 1000;\n        /** 一次迭代的平均移动距离小于该值时停止迭代 */\n        this.minMovement = 0.5;\n        /** 迭代中衰减 */\n        this.interval = 0.02;\n        /** 斥力的一个系数 */\n        this.factor = 1;\n        /** 理想边长 */\n        this.linkDistance = 1;\n        /** 重力大小 */\n        this.gravity = 10;\n        /** 是否启用web worker。前提是在web worker里执行布局，否则无效\t*/\n        this.workerEnabled = false;\n        this.nodes = [];\n        this.edges = [];\n        this.width = 300;\n        this.height = 300;\n        this.nodeMap = {};\n        this.nodeIdxMap = {};\n        this.updateCfg(options);\n    }\n    getDefaultCfg() {\n        return {\n            maxIteration: 2000,\n            gravity: 10,\n            clustering: false,\n            clusterGravity: 10\n        };\n    }\n    /**\n     * 执行布局\n     */\n    execute() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const self = this;\n            const nodes = self.nodes;\n            if (!nodes || nodes.length === 0) {\n                if (self.onLayoutEnd)\n                    self.onLayoutEnd();\n                return;\n            }\n            if (!self.width && typeof window !== \"undefined\") {\n                self.width = window.innerWidth;\n            }\n            if (!self.height && typeof window !== \"undefined\") {\n                self.height = window.innerHeight;\n            }\n            if (!self.center) {\n                self.center = [self.width / 2, self.height / 2];\n            }\n            const center = self.center;\n            if (nodes.length === 1) {\n                nodes[0].x = center[0];\n                nodes[0].y = center[1];\n                if (self.onLayoutEnd)\n                    self.onLayoutEnd();\n                return;\n            }\n            const nodeMap = {};\n            const nodeIdxMap = {};\n            nodes.forEach((node, i) => {\n                if (!isNumber(node.x))\n                    node.x = Math.random() * self.width;\n                if (!isNumber(node.y))\n                    node.y = Math.random() * self.height;\n                nodeMap[node.id] = node;\n                nodeIdxMap[node.id] = i;\n            });\n            self.nodeMap = nodeMap;\n            self.nodeIdxMap = nodeIdxMap;\n            self.nodeStrength = proccessToFunc(self.nodeStrength, 1);\n            self.edgeStrength = proccessToFunc(self.edgeStrength, 1);\n            // layout\n            yield self.run();\n        });\n    }\n    executeWithWorker(canvas, ctx) {\n        const self = this;\n        const nodes = self.nodes;\n        const center = self.center;\n        if (!nodes || nodes.length === 0) {\n            return;\n        }\n        if (nodes.length === 1) {\n            nodes[0].x = center[0];\n            nodes[0].y = center[1];\n            return;\n        }\n        const nodeMap = {};\n        const nodeIdxMap = {};\n        nodes.forEach((node, i) => {\n            if (!isNumber(node.x))\n                node.x = Math.random() * self.width;\n            if (!isNumber(node.y))\n                node.y = Math.random() * self.height;\n            nodeMap[node.id] = node;\n            nodeIdxMap[node.id] = i;\n        });\n        self.nodeMap = nodeMap;\n        self.nodeIdxMap = nodeIdxMap;\n        self.nodeStrength = proccessToFunc(self.nodeStrength, 1);\n        self.edgeStrength = proccessToFunc(self.edgeStrength, 1);\n        // layout\n        self.run(canvas, ctx);\n    }\n    run(canvas, ctx) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const self = this;\n            const nodes = self.nodes;\n            const edges = self.edges;\n            const maxIteration = self.maxIteration;\n            if (!self.width && typeof window !== \"undefined\") {\n                self.width = window.innerWidth;\n            }\n            if (!self.height && typeof window !== \"undefined\") {\n                self.height = window.innerHeight;\n            }\n            const numParticles = nodes.length;\n            self.linkDistance = proccessToFunc(self.linkDistance);\n            self.edgeStrength = proccessToFunc(self.edgeStrength);\n            const { maxEdgePerVetex, array: nodesEdgesArray } = buildTextureDataWithTwoEdgeAttr(nodes, edges, self.linkDistance, self.edgeStrength);\n            // init degree for mass\n            self.degrees = getDegree(nodes.length, self.nodeIdxMap, edges);\n            const masses = [];\n            const nodeStrengths = [];\n            const centerXs = [];\n            const centerYs = [];\n            const centerGravities = [];\n            const fxs = [];\n            const fys = [];\n            if (!self.getMass) {\n                self.getMass = (d) => {\n                    return self.degrees[self.nodeIdxMap[d.id]] || 1;\n                };\n            }\n            const gravity = self.gravity;\n            const center = self.center;\n            nodes.forEach((node, i) => {\n                masses.push(self.getMass(node));\n                nodeStrengths.push(self.nodeStrength(node));\n                if (!self.degrees[i])\n                    self.degrees[i] = 0;\n                let nodeGravity = [center[0], center[1], gravity];\n                if (self.getCenter) {\n                    const customCenter = self.getCenter(node, self.degrees[i]);\n                    if (customCenter &&\n                        isNumber(customCenter[0]) &&\n                        isNumber(customCenter[1]) &&\n                        isNumber(customCenter[2])) {\n                        nodeGravity = customCenter;\n                    }\n                }\n                centerXs.push(nodeGravity[0]);\n                centerYs.push(nodeGravity[1]);\n                centerGravities.push(nodeGravity[2]);\n                if (isNumber(node.fx) && isNumber(node.fy)) {\n                    fxs.push(node.fx || 0.001);\n                    fys.push(node.fy || 0.001);\n                }\n                else {\n                    fxs.push(0);\n                    fys.push(0);\n                }\n            });\n            // 每个节点的额外属性占两个数组各一格，nodeAttributeArray1 中是：mass, degree, nodeSterngth, 0\n            const nodeAttributeArray1 = arrayToTextureData([\n                masses,\n                self.degrees,\n                nodeStrengths,\n                fxs\n            ]);\n            // nodeAttributeArray2 中是：centerX, centerY, gravity, 0,\n            const nodeAttributeArray2 = arrayToTextureData([\n                centerXs,\n                centerYs,\n                centerGravities,\n                fys\n            ]);\n            const workerEnabled = self.workerEnabled;\n            let world;\n            if (workerEnabled) {\n                world = World.create({\n                    canvas,\n                    engineOptions: {\n                        supportCompute: true\n                    }\n                });\n            }\n            else {\n                world = World.create({\n                    engineOptions: {\n                        supportCompute: true\n                    }\n                });\n            }\n            // TODO: 最终的预编译代码放入到 gForceShader.ts 中直接引入，不再需要下面三行\n            // const compiler = new Compiler();\n            // const gForceBundle = compiler.compileBundle(gForceCode);\n            // console.log(gForceBundle.toString());\n            const onLayoutEnd = self.onLayoutEnd;\n            const initPreviousData = [];\n            nodesEdgesArray.forEach((value) => {\n                initPreviousData.push(value);\n            });\n            for (let i = 0; i < 4; i++) {\n                initPreviousData.push(0);\n            }\n            const kernelGForce = world\n                .createKernel(gForceBundle)\n                .setDispatch([numParticles, 1, 1])\n                .setBinding({\n                u_Data: nodesEdgesArray,\n                u_damping: self.damping,\n                u_maxSpeed: self.maxSpeed,\n                u_minMovement: self.minMovement,\n                u_coulombDisScale: self.coulombDisScale,\n                u_factor: self.factor,\n                u_NodeAttributeArray1: nodeAttributeArray1,\n                u_NodeAttributeArray2: nodeAttributeArray2,\n                MAX_EDGE_PER_VERTEX: maxEdgePerVetex,\n                VERTEX_COUNT: numParticles,\n                u_AveMovement: initPreviousData,\n                u_interval: self.interval // 每次迭代更新，首次设置为 interval，在 onIterationCompleted 中更新\n            });\n            // const aveMovementBundle = compiler.compileBundle(aveMovementCode);\n            // console.log(aveMovementBundle.toString());\n            const kernelAveMovement = world\n                .createKernel(aveMovementBundle)\n                .setDispatch([1, 1, 1])\n                .setBinding({\n                u_Data: nodesEdgesArray,\n                VERTEX_COUNT: numParticles,\n                u_AveMovement: [0, 0, 0, 0]\n            });\n            // 执行迭代\n            // let midRes = nodesEdgesArray;\n            const execute = () => __awaiter(this, void 0, void 0, function* () {\n                for (let i = 0; i < maxIteration; i++) {\n                    // TODO: 似乎都来自 kernelGForce 是一个引用\n                    // 当前坐标作为下一次迭代的 PreviousData\n                    // if (i > 0) {\n                    //   kernelAveMovement.setBinding({\n                    //     u_PreviousData: kernelGForce\n                    //   });\n                    // }\n                    // eslint-disable-next-line no-await-in-loop\n                    yield kernelGForce.execute();\n                    // midRes = await kernelGForce.getOutput();\n                    // 每次迭代完成后\n                    // 计算平均位移，用于提前终止迭代\n                    kernelAveMovement.setBinding({\n                        u_Data: kernelGForce\n                    });\n                    // eslint-disable-next-line no-await-in-loop\n                    yield kernelAveMovement.execute();\n                    // 更新衰减函数\n                    const stepInterval = Math.max(0.02, self.interval - i * 0.002);\n                    kernelGForce.setBinding({\n                        u_interval: stepInterval,\n                        u_AveMovement: kernelAveMovement\n                    });\n                }\n                const finalParticleData = yield kernelGForce.getOutput();\n                // 所有迭代完成后\n                if (canvas) {\n                    // 传递数据给主线程\n                    ctx.postMessage({\n                        type: LAYOUT_MESSAGE.GPUEND,\n                        vertexEdgeData: finalParticleData\n                        // edgeIndexBufferData,\n                    });\n                }\n                else {\n                    nodes.forEach((node, i) => {\n                        const x = finalParticleData[4 * i];\n                        const y = finalParticleData[4 * i + 1];\n                        node.x = x;\n                        node.y = y;\n                    });\n                }\n                if (onLayoutEnd)\n                    onLayoutEnd();\n            });\n            yield execute();\n        });\n    }\n    getType() {\n        return \"gForce-gpu\";\n    }\n}\n//# sourceMappingURL=gForce.js.map"]},"metadata":{},"sourceType":"module"}