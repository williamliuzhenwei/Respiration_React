{"ast":null,"code":"import _classCallCheck from \"/Users/liuzhenwei/Desktop/Respiration_React/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/liuzhenwei/Desktop/Respiration_React/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/liuzhenwei/Desktop/Respiration_React/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/liuzhenwei/Desktop/Respiration_React/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/**\n * @fileOverview fruchterman layout\n * @author shiwu.wyy@antfin.com\n */\nimport { Base } from \"./base\";\nimport { getEdgeTerminal, isNumber } from \"../util\";\nvar SPEED_DIVISOR = 800;\n/**\n * fruchterman 布局\n */\n\nexport var FruchtermanLayout = /*#__PURE__*/function (_Base) {\n  _inherits(FruchtermanLayout, _Base);\n\n  var _super = _createSuper(FruchtermanLayout);\n\n  function FruchtermanLayout(options) {\n    var _this;\n\n    _classCallCheck(this, FruchtermanLayout);\n\n    _this = _super.call(this);\n    /** 停止迭代的最大迭代数 */\n\n    _this.maxIteration = 1000;\n    /** 重力大小，影响图的紧凑程度 */\n\n    _this.gravity = 10;\n    /** 速度 */\n\n    _this.speed = 5;\n    /** 是否产生聚类力 */\n\n    _this.clustering = false;\n    /** 聚类力大小 */\n\n    _this.clusterGravity = 10;\n    _this.nodes = [];\n    _this.edges = [];\n    _this.width = 300;\n    _this.height = 300;\n    _this.nodeMap = {};\n    _this.nodeIdxMap = {};\n    /** 迭代结束的回调函数 */\n\n    _this.onLayoutEnd = function () {};\n    /** 每次迭代结束的回调函数 */\n\n\n    _this.tick = function () {};\n\n    _this.updateCfg(options);\n\n    return _this;\n  }\n\n  _createClass(FruchtermanLayout, [{\n    key: \"getDefaultCfg\",\n    value: function getDefaultCfg() {\n      return {\n        maxIteration: 1000,\n        gravity: 10,\n        speed: 1,\n        clustering: false,\n        clusterGravity: 10\n      };\n    }\n    /**\n     * 执行布局\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute() {\n      var _this2 = this;\n\n      var self = this;\n      var nodes = self.nodes;\n\n      if (self.timeInterval !== undefined && typeof window !== \"undefined\") {\n        window.clearInterval(self.timeInterval);\n      }\n\n      if (!nodes || nodes.length === 0) {\n        if (self.onLayoutEnd) self.onLayoutEnd();\n        return;\n      }\n\n      if (!self.width && typeof window !== \"undefined\") {\n        self.width = window.innerWidth;\n      }\n\n      if (!self.height && typeof window !== \"undefined\") {\n        self.height = window.innerHeight;\n      }\n\n      if (!self.center) {\n        self.center = [self.width / 2, self.height / 2];\n      }\n\n      var center = self.center;\n\n      if (nodes.length === 1) {\n        nodes[0].x = center[0];\n        nodes[0].y = center[1];\n        if (self.onLayoutEnd) self.onLayoutEnd();\n        return;\n      }\n\n      var nodeMap = {};\n      var nodeIdxMap = {};\n      nodes.forEach(function (node, i) {\n        if (!isNumber(node.x)) node.x = Math.random() * _this2.width;\n        if (!isNumber(node.y)) node.y = Math.random() * _this2.height;\n        nodeMap[node.id] = node;\n        nodeIdxMap[node.id] = i;\n      });\n      self.nodeMap = nodeMap;\n      self.nodeIdxMap = nodeIdxMap; // layout\n\n      return self.run();\n    }\n  }, {\n    key: \"run\",\n    value: function run() {\n      var self = this;\n      var nodes = self.nodes;\n      if (!nodes) return;\n      var edges = self.edges;\n      var maxIteration = self.maxIteration;\n      var center = self.center;\n      var area = self.height * self.width;\n      var maxDisplace = Math.sqrt(area) / 10;\n      var k2 = area / (nodes.length + 1);\n      var k = Math.sqrt(k2);\n      var gravity = self.gravity;\n      var speed = self.speed;\n      var clustering = self.clustering;\n      var clusterMap = {};\n\n      if (clustering) {\n        nodes.forEach(function (n) {\n          if (clusterMap[n.cluster] === undefined) {\n            var cluster = {\n              name: n.cluster,\n              cx: 0,\n              cy: 0,\n              count: 0\n            };\n            clusterMap[n.cluster] = cluster;\n          }\n\n          var c = clusterMap[n.cluster];\n\n          if (isNumber(n.x)) {\n            c.cx += n.x;\n          }\n\n          if (isNumber(n.y)) {\n            c.cy += n.y;\n          }\n\n          c.count++;\n        });\n\n        for (var key in clusterMap) {\n          clusterMap[key].cx /= clusterMap[key].count;\n          clusterMap[key].cy /= clusterMap[key].count;\n        }\n      }\n\n      if (typeof window === \"undefined\") return;\n      var iter = 0; // interval for render the result after each iteration\n\n      this.timeInterval = window.setInterval(function () {\n        if (!nodes) return; // for (let i = 0; i < maxIteration; i++) {\n\n        var displacements = [];\n        nodes.forEach(function (_, j) {\n          displacements[j] = {\n            x: 0,\n            y: 0\n          };\n        });\n        self.applyCalculate(nodes, edges, displacements, k, k2); // gravity for clusters\n\n        if (clustering) {\n          var clusterGravity = self.clusterGravity || gravity;\n          nodes.forEach(function (n, j) {\n            if (!isNumber(n.x) || !isNumber(n.y)) return;\n            var c = clusterMap[n.cluster];\n            var distLength = Math.sqrt((n.x - c.cx) * (n.x - c.cx) + (n.y - c.cy) * (n.y - c.cy));\n            var gravityForce = k * clusterGravity;\n            displacements[j].x -= gravityForce * (n.x - c.cx) / distLength;\n            displacements[j].y -= gravityForce * (n.y - c.cy) / distLength;\n          });\n\n          for (var _key in clusterMap) {\n            clusterMap[_key].cx = 0;\n            clusterMap[_key].cy = 0;\n            clusterMap[_key].count = 0;\n          }\n\n          nodes.forEach(function (n) {\n            var c = clusterMap[n.cluster];\n\n            if (isNumber(n.x)) {\n              c.cx += n.x;\n            }\n\n            if (isNumber(n.y)) {\n              c.cy += n.y;\n            }\n\n            c.count++;\n          });\n\n          for (var _key2 in clusterMap) {\n            clusterMap[_key2].cx /= clusterMap[_key2].count;\n            clusterMap[_key2].cy /= clusterMap[_key2].count;\n          }\n        } // gravity\n\n\n        nodes.forEach(function (n, j) {\n          if (!isNumber(n.x) || !isNumber(n.y)) return;\n          var gravityForce = 0.01 * k * gravity;\n          displacements[j].x -= gravityForce * (n.x - center[0]);\n          displacements[j].y -= gravityForce * (n.y - center[1]);\n        }); // move\n\n        nodes.forEach(function (n, j) {\n          if (isNumber(n.fx) && isNumber(n.fy)) {\n            n.x = n.fx;\n            n.y = n.fy;\n            return;\n          }\n\n          if (!isNumber(n.x) || !isNumber(n.y)) return;\n          var distLength = Math.sqrt(displacements[j].x * displacements[j].x + displacements[j].y * displacements[j].y);\n\n          if (distLength > 0) {\n            // && !n.isFixed()\n            var limitedDist = Math.min(maxDisplace * (speed / SPEED_DIVISOR), distLength);\n            n.x += displacements[j].x / distLength * limitedDist;\n            n.y += displacements[j].y / distLength * limitedDist;\n          }\n        });\n        if (self.tick) self.tick();\n        iter++;\n\n        if (iter >= maxIteration) {\n          if (self.onLayoutEnd) self.onLayoutEnd();\n          window.clearInterval(self.timeInterval);\n        }\n      }, 0);\n      return {\n        nodes: nodes,\n        edges: edges\n      };\n    }\n  }, {\n    key: \"applyCalculate\",\n    value: function applyCalculate(nodes, edges, displacements, k, k2) {\n      var self = this;\n      self.calRepulsive(nodes, displacements, k2);\n      if (edges) self.calAttractive(edges, displacements, k);\n    }\n  }, {\n    key: \"calRepulsive\",\n    value: function calRepulsive(nodes, displacements, k2) {\n      nodes.forEach(function (v, i) {\n        displacements[i] = {\n          x: 0,\n          y: 0\n        };\n        nodes.forEach(function (u, j) {\n          if (i === j) {\n            return;\n          }\n\n          if (!isNumber(v.x) || !isNumber(u.x) || !isNumber(v.y) || !isNumber(u.y)) {\n            return;\n          }\n\n          var vecX = v.x - u.x;\n          var vecY = v.y - u.y;\n          var vecLengthSqr = vecX * vecX + vecY * vecY;\n\n          if (vecLengthSqr === 0) {\n            vecLengthSqr = 1;\n            var sign = i > j ? 1 : -1;\n            vecX = 0.01 * sign;\n            vecY = 0.01 * sign;\n          }\n\n          var common = k2 / vecLengthSqr;\n          displacements[i].x += vecX * common;\n          displacements[i].y += vecY * common;\n        });\n      });\n    }\n  }, {\n    key: \"calAttractive\",\n    value: function calAttractive(edges, displacements, k) {\n      var _this3 = this;\n\n      edges.forEach(function (e) {\n        var source = getEdgeTerminal(e, 'source');\n        var target = getEdgeTerminal(e, 'target');\n        if (!source || !target) return;\n        var uIndex = _this3.nodeIdxMap[source];\n        var vIndex = _this3.nodeIdxMap[target];\n\n        if (uIndex === vIndex) {\n          return;\n        }\n\n        var u = _this3.nodeMap[source];\n        var v = _this3.nodeMap[target];\n\n        if (!isNumber(v.x) || !isNumber(u.x) || !isNumber(v.y) || !isNumber(u.y)) {\n          return;\n        }\n\n        var vecX = v.x - u.x;\n        var vecY = v.y - u.y;\n        var vecLength = Math.sqrt(vecX * vecX + vecY * vecY);\n        var common = vecLength * vecLength / k;\n        displacements[vIndex].x -= vecX / vecLength * common;\n        displacements[vIndex].y -= vecY / vecLength * common;\n        displacements[uIndex].x += vecX / vecLength * common;\n        displacements[uIndex].y += vecY / vecLength * common;\n      });\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this.timeInterval && typeof window !== \"undefined\") {\n        window.clearInterval(this.timeInterval);\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var self = this;\n      self.stop();\n      self.tick = null;\n      self.nodes = null;\n      self.edges = null;\n      self.destroyed = true;\n    }\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      return \"fruchterman\";\n    }\n  }]);\n\n  return FruchtermanLayout;\n}(Base);","map":{"version":3,"sources":["../../src/layout/fruchterman.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @fileOverview fruchterman layout\n * @author shiwu.wyy@antfin.com\n */\nimport { Base } from \"./base\";\nimport { getEdgeTerminal, isNumber } from \"../util\";\nconst SPEED_DIVISOR = 800;\n/**\n * fruchterman 布局\n */\nexport class FruchtermanLayout extends Base {\n    constructor(options) {\n        super();\n        /** 停止迭代的最大迭代数 */\n        this.maxIteration = 1000;\n        /** 重力大小，影响图的紧凑程度 */\n        this.gravity = 10;\n        /** 速度 */\n        this.speed = 5;\n        /** 是否产生聚类力 */\n        this.clustering = false;\n        /** 聚类力大小 */\n        this.clusterGravity = 10;\n        this.nodes = [];\n        this.edges = [];\n        this.width = 300;\n        this.height = 300;\n        this.nodeMap = {};\n        this.nodeIdxMap = {};\n        /** 迭代结束的回调函数 */\n        this.onLayoutEnd = () => { };\n        /** 每次迭代结束的回调函数 */\n        this.tick = () => { };\n        this.updateCfg(options);\n    }\n    getDefaultCfg() {\n        return {\n            maxIteration: 1000,\n            gravity: 10,\n            speed: 1,\n            clustering: false,\n            clusterGravity: 10\n        };\n    }\n    /**\n     * 执行布局\n     */\n    execute() {\n        const self = this;\n        const nodes = self.nodes;\n        if (self.timeInterval !== undefined && typeof window !== \"undefined\") {\n            window.clearInterval(self.timeInterval);\n        }\n        if (!nodes || nodes.length === 0) {\n            if (self.onLayoutEnd)\n                self.onLayoutEnd();\n            return;\n        }\n        if (!self.width && typeof window !== \"undefined\") {\n            self.width = window.innerWidth;\n        }\n        if (!self.height && typeof window !== \"undefined\") {\n            self.height = window.innerHeight;\n        }\n        if (!self.center) {\n            self.center = [self.width / 2, self.height / 2];\n        }\n        const center = self.center;\n        if (nodes.length === 1) {\n            nodes[0].x = center[0];\n            nodes[0].y = center[1];\n            if (self.onLayoutEnd)\n                self.onLayoutEnd();\n            return;\n        }\n        const nodeMap = {};\n        const nodeIdxMap = {};\n        nodes.forEach((node, i) => {\n            if (!isNumber(node.x))\n                node.x = Math.random() * this.width;\n            if (!isNumber(node.y))\n                node.y = Math.random() * this.height;\n            nodeMap[node.id] = node;\n            nodeIdxMap[node.id] = i;\n        });\n        self.nodeMap = nodeMap;\n        self.nodeIdxMap = nodeIdxMap;\n        // layout\n        return self.run();\n    }\n    run() {\n        const self = this;\n        const nodes = self.nodes;\n        if (!nodes)\n            return;\n        const edges = self.edges;\n        const maxIteration = self.maxIteration;\n        const center = self.center;\n        const area = self.height * self.width;\n        const maxDisplace = Math.sqrt(area) / 10;\n        const k2 = area / (nodes.length + 1);\n        const k = Math.sqrt(k2);\n        const gravity = self.gravity;\n        const speed = self.speed;\n        const clustering = self.clustering;\n        const clusterMap = {};\n        if (clustering) {\n            nodes.forEach((n) => {\n                if (clusterMap[n.cluster] === undefined) {\n                    const cluster = {\n                        name: n.cluster,\n                        cx: 0,\n                        cy: 0,\n                        count: 0\n                    };\n                    clusterMap[n.cluster] = cluster;\n                }\n                const c = clusterMap[n.cluster];\n                if (isNumber(n.x)) {\n                    c.cx += n.x;\n                }\n                if (isNumber(n.y)) {\n                    c.cy += n.y;\n                }\n                c.count++;\n            });\n            for (const key in clusterMap) {\n                clusterMap[key].cx /= clusterMap[key].count;\n                clusterMap[key].cy /= clusterMap[key].count;\n            }\n        }\n        if (typeof window === \"undefined\")\n            return;\n        let iter = 0;\n        // interval for render the result after each iteration\n        this.timeInterval = window.setInterval(() => {\n            if (!nodes)\n                return;\n            // for (let i = 0; i < maxIteration; i++) {\n            const displacements = [];\n            nodes.forEach((_, j) => {\n                displacements[j] = { x: 0, y: 0 };\n            });\n            self.applyCalculate(nodes, edges, displacements, k, k2);\n            // gravity for clusters\n            if (clustering) {\n                const clusterGravity = self.clusterGravity || gravity;\n                nodes.forEach((n, j) => {\n                    if (!isNumber(n.x) || !isNumber(n.y))\n                        return;\n                    const c = clusterMap[n.cluster];\n                    const distLength = Math.sqrt((n.x - c.cx) * (n.x - c.cx) + (n.y - c.cy) * (n.y - c.cy));\n                    const gravityForce = k * clusterGravity;\n                    displacements[j].x -= (gravityForce * (n.x - c.cx)) / distLength;\n                    displacements[j].y -= (gravityForce * (n.y - c.cy)) / distLength;\n                });\n                for (const key in clusterMap) {\n                    clusterMap[key].cx = 0;\n                    clusterMap[key].cy = 0;\n                    clusterMap[key].count = 0;\n                }\n                nodes.forEach((n) => {\n                    const c = clusterMap[n.cluster];\n                    if (isNumber(n.x)) {\n                        c.cx += n.x;\n                    }\n                    if (isNumber(n.y)) {\n                        c.cy += n.y;\n                    }\n                    c.count++;\n                });\n                for (const key in clusterMap) {\n                    clusterMap[key].cx /= clusterMap[key].count;\n                    clusterMap[key].cy /= clusterMap[key].count;\n                }\n            }\n            // gravity\n            nodes.forEach((n, j) => {\n                if (!isNumber(n.x) || !isNumber(n.y))\n                    return;\n                const gravityForce = 0.01 * k * gravity;\n                displacements[j].x -= gravityForce * (n.x - center[0]);\n                displacements[j].y -= gravityForce * (n.y - center[1]);\n            });\n            // move\n            nodes.forEach((n, j) => {\n                if (isNumber(n.fx) && isNumber(n.fy)) {\n                    n.x = n.fx;\n                    n.y = n.fy;\n                    return;\n                }\n                if (!isNumber(n.x) || !isNumber(n.y))\n                    return;\n                const distLength = Math.sqrt(displacements[j].x * displacements[j].x +\n                    displacements[j].y * displacements[j].y);\n                if (distLength > 0) {\n                    // && !n.isFixed()\n                    const limitedDist = Math.min(maxDisplace * (speed / SPEED_DIVISOR), distLength);\n                    n.x += (displacements[j].x / distLength) * limitedDist;\n                    n.y += (displacements[j].y / distLength) * limitedDist;\n                }\n            });\n            if (self.tick)\n                self.tick();\n            iter++;\n            if (iter >= maxIteration) {\n                if (self.onLayoutEnd)\n                    self.onLayoutEnd();\n                window.clearInterval(self.timeInterval);\n            }\n        }, 0);\n        return {\n            nodes,\n            edges\n        };\n    }\n    applyCalculate(nodes, edges, displacements, k, k2) {\n        const self = this;\n        self.calRepulsive(nodes, displacements, k2);\n        if (edges)\n            self.calAttractive(edges, displacements, k);\n    }\n    calRepulsive(nodes, displacements, k2) {\n        nodes.forEach((v, i) => {\n            displacements[i] = { x: 0, y: 0 };\n            nodes.forEach((u, j) => {\n                if (i === j) {\n                    return;\n                }\n                if (!isNumber(v.x) ||\n                    !isNumber(u.x) ||\n                    !isNumber(v.y) ||\n                    !isNumber(u.y)) {\n                    return;\n                }\n                let vecX = v.x - u.x;\n                let vecY = v.y - u.y;\n                let vecLengthSqr = vecX * vecX + vecY * vecY;\n                if (vecLengthSqr === 0) {\n                    vecLengthSqr = 1;\n                    const sign = i > j ? 1 : -1;\n                    vecX = 0.01 * sign;\n                    vecY = 0.01 * sign;\n                }\n                const common = k2 / vecLengthSqr;\n                displacements[i].x += vecX * common;\n                displacements[i].y += vecY * common;\n            });\n        });\n    }\n    calAttractive(edges, displacements, k) {\n        edges.forEach((e) => {\n            const source = getEdgeTerminal(e, 'source');\n            const target = getEdgeTerminal(e, 'target');\n            if (!source || !target)\n                return;\n            const uIndex = this.nodeIdxMap[source];\n            const vIndex = this.nodeIdxMap[target];\n            if (uIndex === vIndex) {\n                return;\n            }\n            const u = this.nodeMap[source];\n            const v = this.nodeMap[target];\n            if (!isNumber(v.x) || !isNumber(u.x) || !isNumber(v.y) || !isNumber(u.y)) {\n                return;\n            }\n            const vecX = v.x - u.x;\n            const vecY = v.y - u.y;\n            const vecLength = Math.sqrt(vecX * vecX + vecY * vecY);\n            const common = (vecLength * vecLength) / k;\n            displacements[vIndex].x -= (vecX / vecLength) * common;\n            displacements[vIndex].y -= (vecY / vecLength) * common;\n            displacements[uIndex].x += (vecX / vecLength) * common;\n            displacements[uIndex].y += (vecY / vecLength) * common;\n        });\n    }\n    stop() {\n        if (this.timeInterval && typeof window !== \"undefined\") {\n            window.clearInterval(this.timeInterval);\n        }\n    }\n    destroy() {\n        const self = this;\n        self.stop();\n        self.tick = null;\n        self.nodes = null;\n        self.edges = null;\n        self.destroyed = true;\n    }\n    getType() {\n        return \"fruchterman\";\n    }\n}\n//# sourceMappingURL=fruchterman.js.map"]},"metadata":{},"sourceType":"module"}