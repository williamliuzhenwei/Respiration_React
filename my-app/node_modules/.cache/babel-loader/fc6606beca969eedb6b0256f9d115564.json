{"ast":null,"code":"import _classCallCheck from \"/Users/liuzhenwei/Desktop/Respiration_React/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/liuzhenwei/Desktop/Respiration_React/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/liuzhenwei/Desktop/Respiration_React/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/liuzhenwei/Desktop/Respiration_React/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/**\n * @fileOverview fruchterman layout\n * @author shiwu.wyy@antfin.com\n */\nimport { Base } from \"./base\";\nimport { isNumber, isFunction, isArray, getDegree, isObject, getEdgeTerminal } from \"../util\";\n\nvar proccessToFunc = function proccessToFunc(value, defaultV) {\n  var func;\n\n  if (!value) {\n    func = function func(d) {\n      return defaultV || 1;\n    };\n  } else if (isNumber(value)) {\n    func = function func(d) {\n      return value;\n    };\n  } else {\n    func = value;\n  }\n\n  return func;\n};\n/**\n * graphin 中的 force 布局\n */\n\n\nexport var GForceLayout = /*#__PURE__*/function (_Base) {\n  _inherits(GForceLayout, _Base);\n\n  var _super = _createSuper(GForceLayout);\n\n  function GForceLayout(options) {\n    var _this;\n\n    _classCallCheck(this, GForceLayout);\n\n    _this = _super.call(this);\n    /** 停止迭代的最大迭代数 */\n\n    _this.maxIteration = 1000;\n    /** 弹簧引力系数 */\n\n    _this.edgeStrength = 200;\n    /** 斥力系数 */\n\n    _this.nodeStrength = 1000;\n    /** 库伦系数 */\n\n    _this.coulombDisScale = 0.005;\n    /** 阻尼系数 */\n\n    _this.damping = 0.9;\n    /** 最大速度 */\n\n    _this.maxSpeed = 1000;\n    /** 一次迭代的平均移动距离小于该值时停止迭代 */\n\n    _this.minMovement = 0.5;\n    /** 迭代中衰减 */\n\n    _this.interval = 0.02;\n    /** 斥力的一个系数 */\n\n    _this.factor = 1;\n    /** 理想边长 */\n\n    _this.linkDistance = 1;\n    /** 重力大小 */\n\n    _this.gravity = 10;\n    /** 是否防止重叠 */\n\n    _this.preventOverlap = true;\n    /** 每次迭代结束的回调函数 */\n\n    _this.tick = function () {};\n\n    _this.nodes = [];\n    _this.edges = [];\n    _this.width = 300;\n    _this.height = 300;\n    _this.nodeMap = {};\n    _this.nodeIdxMap = {};\n\n    _this.updateCfg(options);\n\n    return _this;\n  }\n\n  _createClass(GForceLayout, [{\n    key: \"getDefaultCfg\",\n    value: function getDefaultCfg() {\n      return {\n        maxIteration: 500,\n        gravity: 10,\n        enableTick: true\n      };\n    }\n    /**\n     * 执行布局\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute() {\n      var self = this;\n      var nodes = self.nodes;\n\n      if (self.timeInterval !== undefined && typeof window !== \"undefined\") {\n        window.clearInterval(self.timeInterval);\n      }\n\n      if (!nodes || nodes.length === 0) {\n        if (self.onLayoutEnd) self.onLayoutEnd();\n        return;\n      }\n\n      if (!self.width && typeof window !== \"undefined\") {\n        self.width = window.innerWidth;\n      }\n\n      if (!self.height && typeof window !== \"undefined\") {\n        self.height = window.innerHeight;\n      }\n\n      if (!self.center) {\n        self.center = [self.width / 2, self.height / 2];\n      }\n\n      var center = self.center;\n\n      if (nodes.length === 1) {\n        nodes[0].x = center[0];\n        nodes[0].y = center[1];\n        if (self.onLayoutEnd) self.onLayoutEnd();\n        return;\n      }\n\n      var nodeMap = {};\n      var nodeIdxMap = {};\n      nodes.forEach(function (node, i) {\n        if (!isNumber(node.x)) node.x = Math.random() * self.width;\n        if (!isNumber(node.y)) node.y = Math.random() * self.height;\n        nodeMap[node.id] = node;\n        nodeIdxMap[node.id] = i;\n      });\n      self.nodeMap = nodeMap;\n      self.nodeIdxMap = nodeIdxMap;\n      self.linkDistance = proccessToFunc(self.linkDistance, 1);\n      self.nodeStrength = proccessToFunc(self.nodeStrength, 1);\n      self.edgeStrength = proccessToFunc(self.edgeStrength, 1); // node size function\n\n      var nodeSize = self.nodeSize;\n      var nodeSizeFunc;\n\n      if (self.preventOverlap) {\n        var nodeSpacing = self.nodeSpacing;\n        var nodeSpacingFunc;\n\n        if (isNumber(nodeSpacing)) {\n          nodeSpacingFunc = function nodeSpacingFunc() {\n            return nodeSpacing;\n          };\n        } else if (isFunction(nodeSpacing)) {\n          nodeSpacingFunc = nodeSpacing;\n        } else {\n          nodeSpacingFunc = function nodeSpacingFunc() {\n            return 0;\n          };\n        }\n\n        if (!nodeSize) {\n          nodeSizeFunc = function nodeSizeFunc(d) {\n            if (d.size) {\n              if (isArray(d.size)) {\n                var res = d.size[0] > d.size[1] ? d.size[0] : d.size[1];\n                return res + nodeSpacingFunc(d);\n              }\n\n              if (isObject(d.size)) {\n                var _res = d.size.width > d.size.height ? d.size.width : d.size.height;\n\n                return _res + nodeSpacingFunc(d);\n              }\n\n              return d.size + nodeSpacingFunc(d);\n            }\n\n            return 10 + nodeSpacingFunc(d);\n          };\n        } else if (isArray(nodeSize)) {\n          nodeSizeFunc = function nodeSizeFunc(d) {\n            var res = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];\n            return res + nodeSpacingFunc(d);\n          };\n        } else {\n          nodeSizeFunc = function nodeSizeFunc(d) {\n            return nodeSize + nodeSpacingFunc(d);\n          };\n        }\n      }\n\n      self.nodeSize = nodeSizeFunc;\n      var edges = self.edges;\n      self.degrees = getDegree(nodes.length, self.nodeIdxMap, edges);\n\n      if (!self.getMass) {\n        self.getMass = function (d) {\n          var mass = self.degrees[self.nodeIdxMap[d.id]] || 1;\n          return mass;\n        };\n      } // layout\n\n\n      self.run();\n    }\n  }, {\n    key: \"run\",\n    value: function run() {\n      var self = this;\n      var nodes = self.nodes;\n      var edges = self.edges;\n      var maxIteration = self.maxIteration;\n      if (typeof window === \"undefined\") return;\n      var iter = 0; // interval for render the result after each iteration\n\n      this.timeInterval = window.setInterval(function () {\n        var accArray = [];\n        var velArray = [];\n        if (!nodes) return;\n        nodes.forEach(function (_, i) {\n          accArray[2 * i] = 0;\n          accArray[2 * i + 1] = 0;\n          velArray[2 * i] = 0;\n          velArray[2 * i + 1] = 0;\n        });\n        self.calRepulsive(accArray, nodes);\n        if (edges) self.calAttractive(accArray, edges);\n        self.calGravity(accArray, nodes);\n        var stepInterval = Math.max(0.02, self.interval - iter * 0.002);\n        self.updateVelocity(accArray, velArray, stepInterval, nodes);\n        var previousPos = [];\n        nodes.forEach(function (node) {\n          previousPos.push({\n            x: node.x,\n            y: node.y\n          });\n        });\n        self.updatePosition(velArray, stepInterval, nodes);\n        if (self.tick) self.tick(); // whether to stop the iteration\n\n        var movement = 0;\n        nodes.forEach(function (node, j) {\n          var vx = node.x - previousPos[j].x;\n          var vy = node.y - previousPos[j].y;\n          movement += Math.sqrt(vx * vx + vy * vy);\n        });\n        movement /= nodes.length;\n\n        if (movement < self.minMovement) {\n          window.clearInterval(self.timeInterval);\n          if (self.onLayoutEnd) self.onLayoutEnd();\n        }\n\n        iter++;\n\n        if (iter >= maxIteration) {\n          if (self.onLayoutEnd) self.onLayoutEnd();\n          window.clearInterval(self.timeInterval);\n        }\n      }, 0);\n    }\n  }, {\n    key: \"calRepulsive\",\n    value: function calRepulsive(accArray, nodes) {\n      var self = this; // const nodes = self.nodes;\n\n      var getMass = self.getMass;\n      var nodeStrength = self.nodeStrength;\n      var factor = self.factor;\n      var coulombDisScale = self.coulombDisScale;\n      var preventOverlap = self.preventOverlap;\n      var nodeSize = self.nodeSize;\n      nodes.forEach(function (ni, i) {\n        var massi = getMass ? getMass(ni) : 1;\n        nodes.forEach(function (nj, j) {\n          if (i >= j) return; // if (!accArray[j]) accArray[j] = 0;\n\n          var vecX = ni.x - nj.x;\n          var vecY = ni.y - nj.y;\n          var vecLength = Math.sqrt(vecX * vecX + vecY * vecY) + 0.01;\n          var nVecLength = (vecLength + 0.1) * coulombDisScale;\n          var direX = vecX / vecLength;\n          var direY = vecY / vecLength;\n          var param = (nodeStrength(ni) + nodeStrength(nj)) / 2 * factor / (nVecLength * nVecLength);\n          var massj = getMass ? getMass(nj) : 1;\n          accArray[2 * i] += direX * param;\n          accArray[2 * i + 1] += direY * param;\n          accArray[2 * j] -= direX * param;\n          accArray[2 * j + 1] -= direY * param;\n\n          if (preventOverlap && vecLength < (nodeSize(ni) + nodeSize(nj)) / 2) {\n            var paramOverlap = (nodeStrength(ni) + nodeStrength(nj)) / 2 / (vecLength * vecLength);\n            accArray[2 * i] += direX * paramOverlap / massi;\n            accArray[2 * i + 1] += direY * paramOverlap / massi;\n            accArray[2 * j] -= direX * paramOverlap / massj;\n            accArray[2 * j + 1] -= direY * paramOverlap / massj;\n          }\n        });\n      });\n    }\n  }, {\n    key: \"calAttractive\",\n    value: function calAttractive(accArray, edges) {\n      var self = this; // const edges = self.edges;\n\n      var nodeMap = self.nodeMap;\n      var nodeIdxMap = self.nodeIdxMap;\n      var linkDistance = self.linkDistance;\n      var edgeStrength = self.edgeStrength;\n      var getMass = self.getMass;\n      edges.forEach(function (edge, i) {\n        var source = getEdgeTerminal(edge, 'source');\n        var target = getEdgeTerminal(edge, 'target');\n        var sourceNode = nodeMap[source];\n        var targetNode = nodeMap[target];\n        var vecX = targetNode.x - sourceNode.x;\n        var vecY = targetNode.y - sourceNode.y;\n        var vecLength = Math.sqrt(vecX * vecX + vecY * vecY) + 0.01;\n        var direX = vecX / vecLength;\n        var direY = vecY / vecLength;\n        var length = linkDistance(edge) || 1;\n        var diff = length - vecLength;\n        var param = diff * edgeStrength(edge);\n        var sourceIdx = nodeIdxMap[source];\n        var targetIdx = nodeIdxMap[target];\n        var massSource = getMass ? getMass(sourceNode) : 1;\n        var massTarget = getMass ? getMass(targetNode) : 1;\n        accArray[2 * sourceIdx] -= direX * param / massSource;\n        accArray[2 * sourceIdx + 1] -= direY * param / massSource;\n        accArray[2 * targetIdx] += direX * param / massTarget;\n        accArray[2 * targetIdx + 1] += direY * param / massTarget;\n      });\n    }\n  }, {\n    key: \"calGravity\",\n    value: function calGravity(accArray, nodes) {\n      var self = this; // const nodes = self.nodes;\n\n      var center = self.center;\n      var defaultGravity = self.gravity;\n      var degrees = self.degrees;\n      var nodeLength = nodes.length;\n\n      for (var i = 0; i < nodeLength; i++) {\n        var node = nodes[i];\n        var vecX = node.x - center[0];\n        var vecY = node.y - center[1];\n        var gravity = defaultGravity;\n\n        if (self.getCenter) {\n          var customCenterOpt = self.getCenter(node, degrees[i]);\n\n          if (customCenterOpt && isNumber(customCenterOpt[0]) && isNumber(customCenterOpt[1]) && isNumber(customCenterOpt[2])) {\n            vecX = node.x - customCenterOpt[0];\n            vecY = node.y - customCenterOpt[1];\n            gravity = customCenterOpt[2];\n          }\n        }\n\n        if (!gravity) continue;\n        accArray[2 * i] -= gravity * vecX;\n        accArray[2 * i + 1] -= gravity * vecY;\n      }\n    }\n  }, {\n    key: \"updateVelocity\",\n    value: function updateVelocity(accArray, velArray, stepInterval, nodes) {\n      var self = this;\n      var param = stepInterval * self.damping; // const nodes = self.nodes;\n\n      nodes.forEach(function (node, i) {\n        var vx = accArray[2 * i] * param || 0.01;\n        var vy = accArray[2 * i + 1] * param || 0.01;\n        var vLength = Math.sqrt(vx * vx + vy * vy);\n\n        if (vLength > self.maxSpeed) {\n          var param2 = self.maxSpeed / vLength;\n          vx = param2 * vx;\n          vy = param2 * vy;\n        }\n\n        velArray[2 * i] = vx;\n        velArray[2 * i + 1] = vy;\n      });\n    }\n  }, {\n    key: \"updatePosition\",\n    value: function updatePosition(velArray, stepInterval, nodes) {\n      nodes.forEach(function (node, i) {\n        if (isNumber(node.fx) && isNumber(node.fy)) {\n          node.x = node.fx;\n          node.y = node.fy;\n          return;\n        }\n\n        var distX = velArray[2 * i] * stepInterval;\n        var distY = velArray[2 * i + 1] * stepInterval;\n        node.x += distX;\n        node.y += distY;\n      });\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this.timeInterval && typeof window !== \"undefined\") {\n        window.clearInterval(this.timeInterval);\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var self = this;\n      self.stop();\n      self.tick = null;\n      self.nodes = null;\n      self.edges = null;\n      self.destroyed = true;\n    }\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      return \"gForce\";\n    }\n  }]);\n\n  return GForceLayout;\n}(Base);","map":{"version":3,"sources":["../../src/layout/gForce.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @fileOverview fruchterman layout\n * @author shiwu.wyy@antfin.com\n */\nimport { Base } from \"./base\";\nimport { isNumber, isFunction, isArray, getDegree, isObject, getEdgeTerminal } from \"../util\";\nconst proccessToFunc = (value, defaultV) => {\n    let func;\n    if (!value) {\n        func = (d) => {\n            return defaultV || 1;\n        };\n    }\n    else if (isNumber(value)) {\n        func = (d) => {\n            return value;\n        };\n    }\n    else {\n        func = value;\n    }\n    return func;\n};\n/**\n * graphin 中的 force 布局\n */\nexport class GForceLayout extends Base {\n    constructor(options) {\n        super();\n        /** 停止迭代的最大迭代数 */\n        this.maxIteration = 1000;\n        /** 弹簧引力系数 */\n        this.edgeStrength = 200;\n        /** 斥力系数 */\n        this.nodeStrength = 1000;\n        /** 库伦系数 */\n        this.coulombDisScale = 0.005;\n        /** 阻尼系数 */\n        this.damping = 0.9;\n        /** 最大速度 */\n        this.maxSpeed = 1000;\n        /** 一次迭代的平均移动距离小于该值时停止迭代 */\n        this.minMovement = 0.5;\n        /** 迭代中衰减 */\n        this.interval = 0.02;\n        /** 斥力的一个系数 */\n        this.factor = 1;\n        /** 理想边长 */\n        this.linkDistance = 1;\n        /** 重力大小 */\n        this.gravity = 10;\n        /** 是否防止重叠 */\n        this.preventOverlap = true;\n        /** 每次迭代结束的回调函数 */\n        this.tick = () => { };\n        this.nodes = [];\n        this.edges = [];\n        this.width = 300;\n        this.height = 300;\n        this.nodeMap = {};\n        this.nodeIdxMap = {};\n        this.updateCfg(options);\n    }\n    getDefaultCfg() {\n        return {\n            maxIteration: 500,\n            gravity: 10,\n            enableTick: true\n        };\n    }\n    /**\n     * 执行布局\n     */\n    execute() {\n        const self = this;\n        const nodes = self.nodes;\n        if (self.timeInterval !== undefined && typeof window !== \"undefined\") {\n            window.clearInterval(self.timeInterval);\n        }\n        if (!nodes || nodes.length === 0) {\n            if (self.onLayoutEnd)\n                self.onLayoutEnd();\n            return;\n        }\n        if (!self.width && typeof window !== \"undefined\") {\n            self.width = window.innerWidth;\n        }\n        if (!self.height && typeof window !== \"undefined\") {\n            self.height = window.innerHeight;\n        }\n        if (!self.center) {\n            self.center = [self.width / 2, self.height / 2];\n        }\n        const center = self.center;\n        if (nodes.length === 1) {\n            nodes[0].x = center[0];\n            nodes[0].y = center[1];\n            if (self.onLayoutEnd)\n                self.onLayoutEnd();\n            return;\n        }\n        const nodeMap = {};\n        const nodeIdxMap = {};\n        nodes.forEach((node, i) => {\n            if (!isNumber(node.x))\n                node.x = Math.random() * self.width;\n            if (!isNumber(node.y))\n                node.y = Math.random() * self.height;\n            nodeMap[node.id] = node;\n            nodeIdxMap[node.id] = i;\n        });\n        self.nodeMap = nodeMap;\n        self.nodeIdxMap = nodeIdxMap;\n        self.linkDistance = proccessToFunc(self.linkDistance, 1);\n        self.nodeStrength = proccessToFunc(self.nodeStrength, 1);\n        self.edgeStrength = proccessToFunc(self.edgeStrength, 1);\n        // node size function\n        const nodeSize = self.nodeSize;\n        let nodeSizeFunc;\n        if (self.preventOverlap) {\n            const nodeSpacing = self.nodeSpacing;\n            let nodeSpacingFunc;\n            if (isNumber(nodeSpacing)) {\n                nodeSpacingFunc = () => nodeSpacing;\n            }\n            else if (isFunction(nodeSpacing)) {\n                nodeSpacingFunc = nodeSpacing;\n            }\n            else {\n                nodeSpacingFunc = () => 0;\n            }\n            if (!nodeSize) {\n                nodeSizeFunc = (d) => {\n                    if (d.size) {\n                        if (isArray(d.size)) {\n                            const res = d.size[0] > d.size[1] ? d.size[0] : d.size[1];\n                            return res + nodeSpacingFunc(d);\n                        }\n                        if (isObject(d.size)) {\n                            const res = d.size.width > d.size.height ? d.size.width : d.size.height;\n                            return res + nodeSpacingFunc(d);\n                        }\n                        return d.size + nodeSpacingFunc(d);\n                    }\n                    return 10 + nodeSpacingFunc(d);\n                };\n            }\n            else if (isArray(nodeSize)) {\n                nodeSizeFunc = (d) => {\n                    const res = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];\n                    return res + nodeSpacingFunc(d);\n                };\n            }\n            else {\n                nodeSizeFunc = (d) => nodeSize + nodeSpacingFunc(d);\n            }\n        }\n        self.nodeSize = nodeSizeFunc;\n        const edges = self.edges;\n        self.degrees = getDegree(nodes.length, self.nodeIdxMap, edges);\n        if (!self.getMass) {\n            self.getMass = (d) => {\n                const mass = self.degrees[self.nodeIdxMap[d.id]] || 1;\n                return mass;\n            };\n        }\n        // layout\n        self.run();\n    }\n    run() {\n        const self = this;\n        const nodes = self.nodes;\n        const edges = self.edges;\n        const maxIteration = self.maxIteration;\n        if (typeof window === \"undefined\")\n            return;\n        let iter = 0;\n        // interval for render the result after each iteration\n        this.timeInterval = window.setInterval(() => {\n            const accArray = [];\n            const velArray = [];\n            if (!nodes)\n                return;\n            nodes.forEach((_, i) => {\n                accArray[2 * i] = 0;\n                accArray[2 * i + 1] = 0;\n                velArray[2 * i] = 0;\n                velArray[2 * i + 1] = 0;\n            });\n            self.calRepulsive(accArray, nodes);\n            if (edges)\n                self.calAttractive(accArray, edges);\n            self.calGravity(accArray, nodes);\n            const stepInterval = Math.max(0.02, self.interval - iter * 0.002);\n            self.updateVelocity(accArray, velArray, stepInterval, nodes);\n            const previousPos = [];\n            nodes.forEach((node) => {\n                previousPos.push({\n                    x: node.x,\n                    y: node.y\n                });\n            });\n            self.updatePosition(velArray, stepInterval, nodes);\n            if (self.tick)\n                self.tick();\n            // whether to stop the iteration\n            let movement = 0;\n            nodes.forEach((node, j) => {\n                const vx = node.x - previousPos[j].x;\n                const vy = node.y - previousPos[j].y;\n                movement += Math.sqrt(vx * vx + vy * vy);\n            });\n            movement /= nodes.length;\n            if (movement < self.minMovement) {\n                window.clearInterval(self.timeInterval);\n                if (self.onLayoutEnd)\n                    self.onLayoutEnd();\n            }\n            iter++;\n            if (iter >= maxIteration) {\n                if (self.onLayoutEnd)\n                    self.onLayoutEnd();\n                window.clearInterval(self.timeInterval);\n            }\n        }, 0);\n    }\n    calRepulsive(accArray, nodes) {\n        const self = this;\n        // const nodes = self.nodes;\n        const getMass = self.getMass;\n        const nodeStrength = self.nodeStrength;\n        const factor = self.factor;\n        const coulombDisScale = self.coulombDisScale;\n        const preventOverlap = self.preventOverlap;\n        const nodeSize = self.nodeSize;\n        nodes.forEach((ni, i) => {\n            const massi = getMass ? getMass(ni) : 1;\n            nodes.forEach((nj, j) => {\n                if (i >= j)\n                    return;\n                // if (!accArray[j]) accArray[j] = 0;\n                const vecX = ni.x - nj.x;\n                const vecY = ni.y - nj.y;\n                const vecLength = Math.sqrt(vecX * vecX + vecY * vecY) + 0.01;\n                const nVecLength = (vecLength + 0.1) * coulombDisScale;\n                const direX = vecX / vecLength;\n                const direY = vecY / vecLength;\n                const param = (((nodeStrength(ni) + nodeStrength(nj)) / 2) * factor) /\n                    (nVecLength * nVecLength);\n                const massj = getMass ? getMass(nj) : 1;\n                accArray[2 * i] += (direX * param);\n                accArray[2 * i + 1] += (direY * param);\n                accArray[2 * j] -= (direX * param);\n                accArray[2 * j + 1] -= (direY * param);\n                if (preventOverlap && vecLength < (nodeSize(ni) + nodeSize(nj)) / 2) {\n                    const paramOverlap = (nodeStrength(ni) + nodeStrength(nj)) / 2 / (vecLength * vecLength);\n                    accArray[2 * i] += (direX * paramOverlap) / massi;\n                    accArray[2 * i + 1] += (direY * paramOverlap) / massi;\n                    accArray[2 * j] -= (direX * paramOverlap) / massj;\n                    accArray[2 * j + 1] -= (direY * paramOverlap) / massj;\n                }\n            });\n        });\n    }\n    calAttractive(accArray, edges) {\n        const self = this;\n        // const edges = self.edges;\n        const nodeMap = self.nodeMap;\n        const nodeIdxMap = self.nodeIdxMap;\n        const linkDistance = self.linkDistance;\n        const edgeStrength = self.edgeStrength;\n        const getMass = self.getMass;\n        edges.forEach((edge, i) => {\n            const source = getEdgeTerminal(edge, 'source');\n            const target = getEdgeTerminal(edge, 'target');\n            const sourceNode = nodeMap[source];\n            const targetNode = nodeMap[target];\n            const vecX = targetNode.x - sourceNode.x;\n            const vecY = targetNode.y - sourceNode.y;\n            const vecLength = Math.sqrt(vecX * vecX + vecY * vecY) + 0.01;\n            const direX = vecX / vecLength;\n            const direY = vecY / vecLength;\n            const length = linkDistance(edge) || 1;\n            const diff = length - vecLength;\n            const param = diff * edgeStrength(edge);\n            const sourceIdx = nodeIdxMap[source];\n            const targetIdx = nodeIdxMap[target];\n            const massSource = getMass ? getMass(sourceNode) : 1;\n            const massTarget = getMass ? getMass(targetNode) : 1;\n            accArray[2 * sourceIdx] -= (direX * param) / massSource;\n            accArray[2 * sourceIdx + 1] -= (direY * param) / massSource;\n            accArray[2 * targetIdx] += (direX * param) / massTarget;\n            accArray[2 * targetIdx + 1] += (direY * param) / massTarget;\n        });\n    }\n    calGravity(accArray, nodes) {\n        const self = this;\n        // const nodes = self.nodes;\n        const center = self.center;\n        const defaultGravity = self.gravity;\n        const degrees = self.degrees;\n        const nodeLength = nodes.length;\n        for (let i = 0; i < nodeLength; i++) {\n            const node = nodes[i];\n            let vecX = node.x - center[0];\n            let vecY = node.y - center[1];\n            let gravity = defaultGravity;\n            if (self.getCenter) {\n                const customCenterOpt = self.getCenter(node, degrees[i]);\n                if (customCenterOpt &&\n                    isNumber(customCenterOpt[0]) &&\n                    isNumber(customCenterOpt[1]) &&\n                    isNumber(customCenterOpt[2])) {\n                    vecX = node.x - customCenterOpt[0];\n                    vecY = node.y - customCenterOpt[1];\n                    gravity = customCenterOpt[2];\n                }\n            }\n            if (!gravity)\n                continue;\n            accArray[2 * i] -= gravity * vecX;\n            accArray[2 * i + 1] -= gravity * vecY;\n        }\n    }\n    updateVelocity(accArray, velArray, stepInterval, nodes) {\n        const self = this;\n        const param = stepInterval * self.damping;\n        // const nodes = self.nodes;\n        nodes.forEach((node, i) => {\n            let vx = accArray[2 * i] * param || 0.01;\n            let vy = accArray[2 * i + 1] * param || 0.01;\n            const vLength = Math.sqrt(vx * vx + vy * vy);\n            if (vLength > self.maxSpeed) {\n                const param2 = self.maxSpeed / vLength;\n                vx = param2 * vx;\n                vy = param2 * vy;\n            }\n            velArray[2 * i] = vx;\n            velArray[2 * i + 1] = vy;\n        });\n    }\n    updatePosition(velArray, stepInterval, nodes) {\n        nodes.forEach((node, i) => {\n            if (isNumber(node.fx) && isNumber(node.fy)) {\n                node.x = node.fx;\n                node.y = node.fy;\n                return;\n            }\n            const distX = velArray[2 * i] * stepInterval;\n            const distY = velArray[2 * i + 1] * stepInterval;\n            node.x += distX;\n            node.y += distY;\n        });\n    }\n    stop() {\n        if (this.timeInterval && typeof window !== \"undefined\") {\n            window.clearInterval(this.timeInterval);\n        }\n    }\n    destroy() {\n        const self = this;\n        self.stop();\n        self.tick = null;\n        self.nodes = null;\n        self.edges = null;\n        self.destroyed = true;\n    }\n    getType() {\n        return \"gForce\";\n    }\n}\n//# sourceMappingURL=gForce.js.map"]},"metadata":{},"sourceType":"module"}